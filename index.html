<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EncounterManager | D&D Initiative & Combat Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- SEO -->
    <meta name="description" content="D&D encounter manager and initiative tracker. Build encounters, roll initiative, track HP, conditions, and legendary actions. Runs entirely in your browser.">
    <meta name="keywords" content="D&D, encounter manager, initiative tracker, combat tracker, DnD 5e, dungeon master tools">
    <meta name="author" content="PromptFerret">

    <!-- Open Graph -->
    <meta property="og:title" content="EncounterManager - D&D Initiative & Combat Tracker">
    <meta property="og:description" content="Build encounters, roll initiative, and track combat. No server, no accounts - runs in your browser.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://promptferret.github.io/EncounterManager/">

    <!-- Cache Control -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

<style>
  :root {
    --bg: #0f0f17;
    --surface: #1a1a2e;
    --surface2: #252545;
    --accent: #7c5cbf;
    --accent-hover: #9b7ed8;
    --accent-glow: rgba(124, 92, 191, 0.25);
    --text: #e8e6f0;
    --text-muted: #8a8a9a;
    --text-dim: #5a5a6a;
    --border: #2a2a3e;
    --success: #4ecb71;
    --warning: #e0b055;
    --error: #e05565;
    --mono: 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
    --radius: 8px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* ── Header ── */
  .header {
    padding: 1.5rem 2rem 1rem;
    text-align: center;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
  }
  .header h1 { font-size: 1.2rem; font-weight: 700; letter-spacing: -0.02em; }
  .header h1 span { color: var(--accent); }
  .header .tagline { color: var(--text-dim); font-size: 0.75rem; margin-top: 0.25rem; }

  /* ── Toolbar ── */
  .toolbar {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
    flex-wrap: wrap;
  }
  .toolbar .sep { width: 1px; height: 1.5rem; background: var(--border); margin: 0 0.25rem; }
  .toolbar .spacer { flex: 1; min-width: 0.5rem; }

  button {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 600;
    transition: all 0.15s;
    background: var(--surface2);
    color: var(--text-muted);
    white-space: nowrap;
  }
  button:hover { background: var(--accent); color: white; border-color: var(--accent); }
  button:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
  .btn-action { background: var(--accent); color: white; border-color: var(--accent); padding: 0.5rem 1.25rem; }
  .btn-action:hover { background: var(--accent-hover); border-color: var(--accent-hover); }
  .btn-toggle.active { background: var(--accent); color: white; border-color: var(--accent); }
  .btn-danger { color: var(--error); border-color: var(--error); background: transparent; }
  .btn-danger:hover { background: var(--error); color: white; }
  .btn-accent { color: var(--accent); border-color: var(--accent); background: transparent; }
  .btn-accent:hover { background: var(--accent); color: white !important; border-color: var(--accent); }
  .btn-success { color: var(--success); border-color: var(--success); background: transparent; }
  .btn-success:hover { background: var(--success); color: white !important; border-color: var(--success); }
  .btn-warning { color: var(--warning); border-color: var(--warning); background: transparent; }
  .btn-warning:hover { background: var(--warning); color: white !important; border-color: var(--warning); }
  .btn-sm { padding: 0.25rem 0.6rem; font-size: 0.72rem; }

  /* ── Status Bar ── */
  #statusEl {
    font-size: 0.75rem;
    padding: 0.35rem 1.5rem;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
    min-height: 1.6rem;
  }
  #statusEl:empty { border-bottom: none; }
  #statusEl.error { color: var(--error); }
  #statusEl.success { color: var(--success); animation: status-flash 0.4s ease-out; }
  #statusEl.warning { color: var(--warning); }
  @keyframes status-flash {
    0% { background: rgba(78, 203, 113, 0.2); }
    100% { background: var(--bg); }
  }

  /* ── Main Layout ── */
  .main {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow-y: auto;
  }

  .view { display: none; padding: 1.25rem 1.5rem; }
  .view.active { display: block; }
  #viewCombat.active { padding-top: 0; }

  /* ── Cards ── */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.85rem 1rem;
    margin-bottom: 0.5rem;
    transition: border-color 0.15s;
  }
  .card:hover { border-color: var(--accent-glow); }
  .card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
  }
  .card-title {
    font-size: 0.88rem;
    font-weight: 700;
    color: var(--accent);
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .card-meta {
    font-size: 0.72rem;
    color: var(--text-dim);
    margin-top: 0.3rem;
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }
  .card-meta span { white-space: nowrap; }
  .card-actions { display: flex; gap: 0.35rem; flex-shrink: 0; }

  /* ── Forms ── */
  .form-section {
    margin-bottom: 1.25rem;
  }
  .form-section-title {
    font-size: 0.78rem;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.04em;
    margin-bottom: 0.5rem;
    padding-bottom: 0.3rem;
    border-bottom: 1px solid var(--border);
  }
  .form-grid {
    display: grid;
    gap: 0.5rem 0.75rem;
  }
  .form-grid.cols-2 { grid-template-columns: 1fr 1fr; }
  .form-grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
  .form-grid.cols-4 { grid-template-columns: 1fr 1fr 1fr 1fr; }
  .form-grid.cols-6 { grid-template-columns: repeat(6, 1fr); }
  .form-field label {
    display: block;
    font-size: 0.68rem;
    color: var(--text-dim);
    margin-bottom: 0.2rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }
  .form-field input,
  .form-field select,
  .form-field textarea {
    width: 100%;
    padding: 0.4rem 0.6rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.8rem;
    font-family: inherit;
    transition: border-color 0.2s;
  }
  .form-field input:focus,
  .form-field select:focus,
  .form-field textarea:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }
  .form-field input::placeholder,
  .form-field textarea::placeholder { color: var(--text-dim); }
  .form-field textarea { resize: vertical; min-height: 2.5rem; font-family: var(--mono); font-size: 0.78rem; }
  .form-field select { cursor: pointer; }
  .form-field input[type="number"] { font-family: var(--mono); }
  .form-field input[type="checkbox"] { width: auto; margin-right: 0.3rem; accent-color: var(--accent); }
  .form-field .checkbox-label {
    display: inline-flex;
    align-items: center;
    font-size: 0.8rem;
    color: var(--text-muted);
    cursor: pointer;
    padding-top: 1.2rem;
  }

  /* Dynamic rows (attacks, features, etc.) */
  .dyn-row {
    display: flex;
    gap: 0.4rem;
    align-items: flex-start;
    margin-bottom: 0.35rem;
    flex-wrap: wrap;
  }
  .dyn-row input,
  .dyn-row select,
  .dyn-row textarea {
    padding: 0.35rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.78rem;
    font-family: inherit;
  }
  .dyn-row input:focus,
  .dyn-row select:focus,
  .dyn-row textarea:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }
  .dyn-row textarea { resize: vertical; min-height: 1.8rem; font-family: var(--mono); font-size: 0.75rem; }
  .btn-remove {
    padding: 0.35rem 0.5rem;
    font-size: 0.78rem;
    line-height: 1.16;
    color: var(--error);
    border: 1px solid var(--error);
    background: transparent;
    flex-shrink: 0;
    cursor: pointer;
    border-radius: var(--radius);
  }
  .btn-remove:hover { background: var(--error); color: white !important; }
  .dyn-label {
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    margin-bottom: 0.15rem;
  }
  .dyn-header {
    display: flex;
    gap: 0.4rem;
    margin-bottom: 0.25rem;
    padding: 0 0.1rem;
  }
  .btn-add-row {
    font-size: 0.72rem;
    padding: 0.25rem 0.75rem;
    margin-top: 0.25rem;
  }

  /* ── Form Actions ── */
  .form-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1.25rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
  }

  /* ── Empty State ── */
  .empty-state {
    text-align: center;
    color: var(--text-dim);
    padding: 3rem 1rem;
    font-size: 0.85rem;
  }
  .empty-state p { margin-bottom: 0.5rem; }

  /* ── Search Bar ── */
  .search-bar {
    margin-bottom: 0.75rem;
  }
  .search-bar input {
    width: 100%;
    padding: 0.45rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.82rem;
  }
  .search-bar input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }
  .search-bar input::placeholder { color: var(--text-dim); }

  /* ── Player List (in party form) ── */
  .player-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem;
    margin-top: 0.3rem;
  }
  .player-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.4rem 0.7rem;
    border: 1px solid var(--accent);
    border-radius: var(--radius);
    font-size: 0.8rem;
    background: var(--accent);
    color: white;
  }
  .player-chip .chip-remove {
    font-size: 0.65rem;
    color: var(--error);
    cursor: pointer;
    margin-left: 0.1rem;
    border: 1px solid var(--error);
    border-radius: 3px;
    padding: 0.1rem 0.25rem;
    background: transparent;
    line-height: 1;
  }
  .player-chip .chip-remove:hover { background: var(--error); color: white; }

  /* ── Monster Picks (in encounter form) ── */
  .monster-pick {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.6rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 0.3rem;
    font-size: 0.8rem;
  }
  .monster-pick .pick-name { flex: 1; color: var(--text); }
  .monster-pick .pick-qty {
    width: 50px;
    padding: 0.2rem 0.4rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.78rem;
    font-family: var(--mono);
    text-align: center;
  }

  /* ── Searchable Select ── */
  .search-select { position: relative; flex: 1; }
  .search-dropdown {
    position: absolute; top: 100%; left: 0; right: 0; z-index: 30;
    max-height: 200px; overflow-y: auto;
    background: var(--surface); border: 1px solid var(--border); border-top: none;
    border-radius: 0 0 var(--radius) var(--radius);
    display: none;
  }
  .search-dropdown.open { display: block; }
  .search-dropdown-item {
    padding: 0.4rem 0.6rem; font-size: 0.8rem; cursor: pointer;
    color: var(--text); border-bottom: 1px solid var(--border);
  }
  .search-dropdown-item:last-child { border-bottom: none; }
  .search-dropdown-item:hover { background: var(--accent); color: white; }
  .search-dropdown-item .cr-tag {
    font-size: 0.65rem; color: var(--text-dim); margin-left: 0.5rem;
  }
  .search-dropdown-item:hover .cr-tag { color: rgba(255,255,255,0.7); }

  /* ── Modal ── */
  .modal-overlay {
    position: fixed; inset: 0; z-index: 100;
    background: rgba(0,0,0,0.6); display: flex;
    align-items: center; justify-content: center;
  }
  .modal-content {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.5rem;
    max-width: 400px; width: 90%;
  }
  .modal-wide { max-width: 480px; }
  .modal-toggle-group {
    display: flex; gap: 0; margin-bottom: 1rem;
  }
  .modal-toggle-group button {
    flex: 1; padding: 0.4rem 0.6rem; font-size: 0.78rem; font-weight: 600;
    border: 1px solid var(--border); border-radius: 0; background: var(--bg); color: var(--text-muted);
    cursor: pointer; transition: background 0.15s, color 0.15s;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 0;
  }
  .modal-toggle-group button:first-child { border-radius: var(--radius) 0 0 var(--radius); }
  .modal-toggle-group button:not(:first-child) { border-left: none; }
  .modal-toggle-group button:last-child { border-radius: 0 var(--radius) var(--radius) 0; }
  .modal-toggle-group button.active {
    background: var(--accent); color: white; border-color: var(--accent);
  }
  .modal-toggle-group button:not(.active):hover { background: var(--surface2); }

  /* ── Footer ── */
  .footer {
    padding: 0.4rem 1.5rem;
    font-size: 0.7rem;
    color: var(--text-dim);
    border-top: 1px solid var(--border);
    background: var(--surface);
    display: flex;
    justify-content: space-between;
  }
  .footer a { color: var(--accent); text-decoration: none; }

  /* ── Combat List ── */
  .combat-list-card {
    background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
    padding: 0.75rem; margin-bottom: 0.5rem; cursor: pointer; transition: border-color 0.15s;
  }
  .combat-list-card:hover { border-color: var(--accent); }
  .combat-list-name { font-weight: 600; font-size: 0.9rem; margin-bottom: 0.3rem; }
  .combat-list-info { display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; }

  /* ── Combat ── */
  .combat-bar {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.35rem 0.75rem;
    margin: 0 -0.75rem 0.35rem;
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
    position: sticky;
    top: 0;
    background: var(--bg);
    z-index: 20;
  }
  .combat-bar .round-badge {
    font-family: var(--mono);
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--accent);
    padding: 0.3rem 0.75rem;
    border: 1px solid var(--accent);
    border-radius: var(--radius);
    white-space: nowrap;
  }

  .combat-info {
    padding: 0.35rem 0.75rem;
    margin: 0 -0.75rem 0.35rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
  }
  .combat-info-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.72rem;
  }
  .combat-info-label {
    font-size: 0.62rem;
    font-weight: 700;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    min-width: 5.5rem;
    flex-shrink: 0;
  }
  .combat-info-value {
    flex: 1;
    color: var(--text-muted);
    min-width: 0;
  }
  .combat-info-copy {
    font-size: 0.6rem !important;
    padding: 0.1rem 0.4rem !important;
    flex-shrink: 0;
  }

  .combatant-row {
    display: grid;
    grid-template-columns: 50px 1fr 50px 120px 40px;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 2px;
    background: var(--surface);
    cursor: pointer;
    transition: border-color 0.15s, opacity 0.15s;
  }
  .combatant-row:hover { border-color: var(--accent-glow); }
  .combatant-row.current-turn {
    border-left: 3px solid var(--accent);
    background: var(--surface2);
  }
  .combatant-row.is-dead {
    opacity: 0.35;
  }
  .combatant-row .init-val {
    font-family: var(--mono);
    font-size: 0.82rem;
    font-weight: 700;
    text-align: center;
    color: var(--text-muted);
  }
  .combatant-row .combatant-name {
    font-size: 0.85rem;
    font-weight: 600;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .combatant-row .combatant-name.type-player { color: var(--success); }
  .combatant-row .combatant-name.type-monster { color: var(--text); }
  .combatant-row .combatant-name.type-adhoc { color: var(--warning); }
  .combatant-row .ac-val {
    font-family: var(--mono);
    font-size: 0.78rem;
    text-align: center;
    color: var(--text-dim);
  }

  .hp-bar-container {
    height: 18px;
    background: var(--bg);
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid var(--border);
    position: relative;
  }
  .hp-bar-fill {
    height: 100%;
    transition: width 0.2s ease;
    border-radius: 3px;
  }
  .hp-bar-fill.hp-high { background: var(--success); }
  .hp-bar-fill.hp-mid { background: var(--warning); }
  .hp-bar-fill.hp-low { background: var(--error); }
  .hp-bar-text {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--mono);
    font-size: 0.65rem;
    font-weight: 700;
    color: var(--text);
    text-shadow: 0 0 3px var(--bg);
  }

  .reaction-indicator {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.65rem;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--text-dim);
  }
  .reaction-indicator.available { border-color: var(--success); color: var(--success); }
  .reaction-indicator.used { border-color: var(--error); color: var(--error); opacity: 0.5; }

  .combatant-detail {
    display: none;
    padding: 0.75rem;
    margin-bottom: 2px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-top: none;
    border-radius: 0 0 var(--radius) var(--radius);
  }
  .combatant-detail.expanded { display: block; }
  .detail-grid {
    display: grid;
    grid-template-columns: 1fr minmax(0, 320px);
    gap: 0.75rem;
  }
  .detail-section-title {
    font-size: 0.7rem;
    font-weight: 700;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    margin-bottom: 0.35rem;
  }

  /* Attribute check/save grid */
  .attr-grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 5.5rem));
    gap: 0.3rem 0.5rem;
    margin-bottom: 0.5rem;
  }
  .attr-cell {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.15rem;
  }
  .attr-label {
    font-size: 0.6rem;
    font-weight: 700;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .attr-sub {
    font-size: 0.5rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    margin-top: 0.1rem;
  }
  .attr-btn {
    width: 100%;
    padding: 0.2rem 0.3rem;
    font-family: var(--mono);
    font-size: 0.72rem;
    text-align: center;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text-muted);
    cursor: pointer;
    transition: border-color 0.15s, color 0.15s;
  }
  .attr-btn:hover {
    border-color: var(--accent);
    color: var(--text);
  }
  .attr-btn.proficient {
    color: var(--accent);
    border-color: var(--accent);
  }
  .attr-btn.proficient:hover {
    color: white;
    background: var(--accent);
  }
  .attr-btn.save-btn {
    font-size: 0.65rem;
    padding: 0.15rem 0.3rem;
    border-style: dashed;
  }
  .attr-btn.save-btn.proficient {
    border-style: solid;
  }

  /* Skill grid */
  .skill-grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 5.5rem));
    gap: 0.3rem 0.5rem;
  }
  .skill-cell {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.1rem;
  }
  .skill-label {
    font-size: 0.6rem;
    color: var(--text-dim);
    text-align: center;
    line-height: 1.1;
  }

  /* Passive stats row */
  .passive-row {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    font-size: 0.72rem;
    font-family: var(--mono);
    color: var(--text-muted);
    margin-bottom: 0.5rem;
  }
  .passive-label {
    color: var(--text-dim);
  }

  .detail-accordion-toggle {
    font-size: 0.7rem;
    font-weight: 700;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    cursor: pointer;
    user-select: none;
    margin-top: 0.5rem;
    padding: 0.25rem 0;
    display: flex;
    align-items: center;
    gap: 0.3rem;
  }
  .detail-accordion-toggle:hover { color: var(--text-muted); }
  .detail-accordion-toggle .arrow { transition: transform 0.15s; display: inline-block; font-size: 0.6rem; }
  .detail-accordion-toggle.open .arrow { transform: rotate(90deg); }
  .detail-accordion-body { display: none; margin-top: 0.3rem; }
  .detail-accordion-body.open { display: block; }

  .init-setup-row {
    display: grid;
    grid-template-columns: 80px 1fr auto 80px;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 0.3rem;
    background: var(--surface);
  }
  .init-setup-row input[type="number"] {
    width: 100%;
    padding: 0.35rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.82rem;
    font-family: var(--mono);
    text-align: center;
  }

  .hp-controls {
    display: flex;
    gap: 0.3rem;
    align-items: center;
    margin-top: 0.35rem;
    flex-wrap: wrap;
  }
  .hp-controls input {
    width: 60px;
    padding: 0.3rem 0.4rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-family: var(--mono);
    font-size: 0.78rem;
    text-align: center;
  }

  .multiattack-box {
    font-size: 0.78rem;
    font-weight: 600;
    color: #c4a8ff;
    padding: 0.35rem 0.6rem;
    margin-top: 0.5rem;
    background: rgba(124, 92, 191, 0.08);
    border: 1px solid rgba(124, 92, 191, 0.25);
    border-radius: var(--radius);
    border-left: 3px solid var(--accent);
  }

  .roll-log {
    font-family: var(--mono);
    font-size: 0.75rem;
    background: var(--bg);
    border-radius: var(--radius);
    border: 1px solid var(--border);
    padding: 0.4rem 0.6rem;
    margin-top: 0.5rem;
  }
  .roll-log-entry {
    color: var(--accent);
    padding: 0.1rem 0;
  }
  .roll-log-entry.crit { color: var(--success); font-weight: 700; }
  .roll-log-entry.fumble { color: var(--error); font-weight: 700; }

  .dice-link {
    color: var(--accent);
    cursor: pointer;
    text-decoration: underline;
    font-family: var(--mono);
  }
  .dice-link:hover { color: var(--text); }

  .la-badge, .lr-badge {
    font-family: var(--mono);
    font-size: 0.6rem;
    padding: 0.05rem 0.3rem;
    border-radius: 4px;
    margin-left: 0.3rem;
  }
  .la-badge { background: rgba(224, 176, 85, 0.15); color: var(--warning); }
  .lr-badge { background: rgba(191, 92, 92, 0.15); color: var(--error); }

  .condition-chip {
    display: inline-block;
    font-size: 0.6rem;
    font-weight: 600;
    padding: 0.1rem 0.4rem;
    border-radius: 9px;
    background: rgba(124, 92, 191, 0.15);
    color: var(--accent);
    border: 1px solid rgba(124, 92, 191, 0.3);
    margin: 0.08rem;
    white-space: nowrap;
  }
  .condition-chip.save-based { background: rgba(224, 176, 85, 0.12); color: var(--warning); border-color: rgba(224, 176, 85, 0.3); }
  .turn-notify {
    font-size: 0.58rem;
    font-weight: 700;
    color: var(--warning);
    background: rgba(224, 176, 85, 0.15);
    border: 1px solid rgba(224, 176, 85, 0.3);
    border-radius: 9px;
    padding: 0.05rem 0.35rem;
    margin-left: 0.2rem;
    white-space: nowrap;
    animation: notify-pulse 1.5s ease-in-out 3;
  }
  @keyframes notify-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .concentration-chip {
    display: inline-block;
    font-size: 0.6rem;
    font-weight: 600;
    padding: 0.1rem 0.4rem;
    border-radius: 9px;
    background: rgba(92, 191, 124, 0.12);
    color: var(--success);
    border: 1px solid rgba(92, 191, 124, 0.3);
    margin: 0.05rem;
    white-space: nowrap;
  }

  /* ── Edit Mode (Combat Overrides) ── */
  .edit-checkbox { accent-color: var(--accent); width: auto; cursor: pointer; }
  .edit-checkbox:disabled { opacity: 0.3; cursor: not-allowed; }
  .override-badge { font-size: 0.7rem; color: var(--warning); margin-left: 0.25rem; vertical-align: middle; }

  /* Roll mode popup */
  #rollModePopup {
    display: none;
    position: fixed;
    z-index: 1000;
    flex-direction: column;
    gap: 0.3rem;
    padding: 0.4rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }
  .combatant-name.has-overrides { color: var(--warning); }
  .override-highlight {
    border-left: 3px solid var(--warning);
    padding-left: 0.4rem;
    background: rgba(224, 176, 85, 0.1);
    border-radius: 2px;
    color: var(--warning);
  }
  .edit-field-modified { border-color: var(--warning) !important; }
  .dice-roller-entry {
    padding: 0.4rem 0.6rem;
    border-bottom: 1px solid var(--border);
    font-size: 0.82rem;
    display: flex;
    align-items: baseline;
    flex-wrap: wrap;
    gap: 0.25rem;
  }
  .dice-roller-entry:last-child { border-bottom: none; }
  .edit-field-conflict { opacity: 0.5; }
  .edit-field-conflict::placeholder { color: var(--text-muted); opacity: 1; font-style: italic; }
  .btn-revert {
    font-size: 0.78rem;
    line-height: 1.16;
    padding: 0.35rem 0.5rem;
    color: var(--warning);
    border: 1px solid var(--warning);
    background: transparent;
    border-radius: var(--radius);
    cursor: pointer;
    white-space: nowrap;
    flex-shrink: 0;
  }
  .btn-revert:hover { background: var(--warning); color: white; }

  /* ── Responsive ── */
  @supports (height: 100dvh) { body { height: 100dvh; } }
  @media (max-width: 640px) {
    .toolbar .sep { display: none; }
    .form-grid.cols-3,
    .form-grid.cols-4 { grid-template-columns: 1fr 1fr; }
    .form-grid.cols-6 { grid-template-columns: repeat(3, 1fr); }
    .view { padding: 1rem; }
    .combatant-row { grid-template-columns: 40px 1fr 40px 80px 30px; }
    .init-setup-row { grid-template-columns: 80px 1fr 80px; }
    .init-setup-row > span:nth-child(3) { display: none; }
    .detail-grid { grid-template-columns: 1fr; }
  }

  /* ── Utility Classes ── */
  .flex-row { display: flex; gap: 0.5rem; align-items: center; }
  .flex-row-tight { display: flex; gap: 0.3rem; align-items: center; }
  .flex-row-end { display: flex; gap: 0.5rem; justify-content: flex-end; }
  .flex-col { display: flex; flex-direction: column; gap: 0.5rem; }
  .text-muted-sm { font-size: 0.78rem; color: var(--text-muted); }
  .text-dim-sm { font-size: 0.72rem; color: var(--text-dim); }
  .text-mono { font-family: var(--mono); font-size: 0.82rem; }
  .detail-label { font-size: 0.78rem; color: var(--text-muted); margin-bottom: 0.3rem; }
</style>
</head>
<body>

<div class="header">
  <h1><span>Encounter</span>Manager</h1>
  <p class="tagline">D&D initiative & combat tracker</p>
</div>

<div class="toolbar">
  <button class="btn-toggle active" id="navTemplates" onclick="switchView('templates')">Monsters</button>
  <button class="btn-toggle" id="navParties" onclick="switchView('parties')">Parties</button>
  <button class="btn-toggle" id="navEncounters" onclick="switchView('encounters')">Encounters</button>
  <button class="btn-toggle" id="navCombat" onclick="activeCombatId=null;switchView('combat')">Combat</button>
  <div class="spacer"></div>
  <button class="btn-toggle" onclick="showDiceRoller()">Roll Dice</button>
  <button class="btn-toggle" onclick="showImportDialog()" title="Load backup">Load Backup</button>
  <button class="btn-toggle" onclick="exportData()" title="Save backup">Save Backup</button>
  <div class="sep"></div>
  <button class="btn-toggle" id="btnImportMonster" onclick="showImportMonsterDialog()">Import Monster</button>
  <button class="btn-action" id="btnNew" onclick="handleNew()">+ New Monster</button>
</div>

<div id="statusEl"></div>

<div id="rollModePopup" onclick="event.stopPropagation()"></div>

<div class="main">
  <div id="viewTemplates" class="view active"></div>
  <div id="viewParties" class="view"></div>
  <div id="viewEncounters" class="view"></div>
  <div id="viewCombat" class="view"></div>
</div>

<div class="footer">
  <span><a href="https://promptferret.github.io" target="_blank">PromptFerret</a> &middot; <a href="https://github.com/PromptFerret/EncounterManager/blob/main/LICENSE" target="_blank">MIT License</a> &middot; Vibe coded with <a href="https://docs.anthropic.com/en/docs/claude-code" target="_blank">Claude Code</a></span>
  <span><a href="https://promptferret.github.io/MarkdownSite/?chrome=false#../../EncounterManager/docs/INDEX" target="_blank">Docs</a> &middot; <a href="https://promptferret.github.io/tools/" target="_blank">All Tools</a> &middot; <span id="storageInfo">Data stored in your browser</span></span>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// ── Constants ──
// ═══════════════════════════════════════════════════════════════

const ABILITIES = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
const ABILITY_NAMES = { str: 'Strength', dex: 'Dexterity', con: 'Constitution', int: 'Intelligence', wis: 'Wisdom', cha: 'Charisma' };
const SKILLS = [
  'Acrobatics', 'Animal Handling', 'Arcana', 'Athletics', 'Deception',
  'History', 'Insight', 'Intimidation', 'Investigation', 'Medicine',
  'Nature', 'Perception', 'Performance', 'Persuasion', 'Religion',
  'Sleight of Hand', 'Stealth', 'Survival'
];
const SKILL_ABILITY_MAP = {
  'Acrobatics': 'dex', 'Animal Handling': 'wis', 'Arcana': 'int',
  'Athletics': 'str', 'Deception': 'cha', 'History': 'int',
  'Insight': 'wis', 'Intimidation': 'cha', 'Investigation': 'int',
  'Medicine': 'wis', 'Nature': 'int', 'Perception': 'wis',
  'Performance': 'cha', 'Persuasion': 'cha', 'Religion': 'int',
  'Sleight of Hand': 'dex', 'Stealth': 'dex', 'Survival': 'wis'
};
const SIZES = ['Tiny', 'Small', 'Medium', 'Large', 'Huge', 'Gargantuan'];
const CONDITIONS = ['Blinded','Charmed','Deafened','Frightened','Grappled','Incapacitated','Invisible','Paralyzed','Petrified','Poisoned','Prone','Restrained','Stunned','Unconscious'];
const STORAGE_KEYS = {
  templates: 'pf_enc_templates',
  encounters: 'pf_enc_encounters',
  parties: 'pf_enc_parties',
  combats: 'pf_enc_combats',
  preferences: 'pf_enc_preferences'
};

// ═══════════════════════════════════════════════════════════════
// ── State ──
// ═══════════════════════════════════════════════════════════════

let state = {
  templates: [],
  encounters: [],
  parties: [],
  combats: [],
  preferences: { view: 'templates' }
};

let currentView = 'templates';
let formState = { mode: null, data: null, savedSnapshot: null }; // mode: null=list, 'template'/'encounter'/'party'; data: working copy; savedSnapshot: for dirty checking
let searchQuery = '';
let activeCombatId = null; // ID of the combat currently being viewed (persisted in preferences)
let autoExpandedId = null; // combatant ID that was auto-expanded on turn start (persisted in preferences)

// ── Edit Mode (Combat Overrides) ──
let editState = {
  mode: false,              // edit mode toggle active
  selected: [],             // array of combatant IDs selected for editing
  lockedTemplateId: null,   // template ID locked on first checkbox selection
  formData: null,           // working copy of template being edited
  visible: false,           // is the edit form showing
  rawTemplate: null,        // raw template for diffing/revert
  formSnapshot: null,       // snapshot of formData at open/save for dirty check
  conflicts: new Set()      // set of field paths where selected combatants disagree
};
let diceRollerHistory = [];        // ephemeral roll history for the dice roller modal
let _exportTargetId = null;        // template ID for export modal

function getActiveCombat() {
  if (!activeCombatId) return null;
  return state.combats.find(c => c.id === activeCombatId) || null;
}

function getCombatant(idx) {
  const combat = getActiveCombat();
  if (!combat || !combat.combatants || idx < 0 || idx >= combat.combatants.length) return null;
  return combat.combatants[idx];
}

// ═══════════════════════════════════════════════════════════════
// ── Utilities ──
// ═══════════════════════════════════════════════════════════════

function uuid() { return crypto.randomUUID(); }
function abilityMod(score) { return Math.floor((score - 10) / 2); }
function modStr(score) { const m = abilityMod(score); return m >= 0 ? '+' + m : '' + m; }
function esc(s) { if (!s) return ''; return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); }

function setStatus(msg, type) {
  const el = document.getElementById('statusEl');
  el.textContent = msg;
  el.className = '';
  void el.offsetWidth; // force reflow to restart animation
  el.className = type || '';
}

function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }
function isFormDirty() { return JSON.stringify(formState.data) !== JSON.stringify(formState.savedSnapshot); }

function calcPassivePerception(t) {
  const wisMod = abilityMod(t.abilities.wis);
  const percSkill = t.skills.find(s => s.name === 'Perception');
  return 10 + (percSkill ? percSkill.bonus : wisMod);
}

function getPassivePerception(t) {
  return t.passivePerception != null ? t.passivePerception : calcPassivePerception(t);
}

function calcPassiveInvestigation(t) {
  const skill = t.skills.find(function(s) { return s.name === 'Investigation'; });
  return 10 + (skill ? skill.bonus : abilityMod(t.abilities.int));
}

function calcPassiveInsight(t) {
  const skill = t.skills.find(function(s) { return s.name === 'Insight'; });
  return 10 + (skill ? skill.bonus : abilityMod(t.abilities.wis));
}

function updatePPDisplay() {
  const auto = calcPassivePerception(formState.data);
  const lbl = document.getElementById('pp_auto');
  const inp = document.getElementById('pp_input');
  if (lbl) lbl.textContent = auto;
  if (inp) inp.placeholder = auto;
}

function newTemplate() {
  return {
    id: uuid(), name: '', size: 'Medium', type: '', alignment: '', ac: 10, acNote: '',
    hpMax: 1, hpFormula: '', speed: '30 ft.', cr: '',
    abilities: { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
    savingThrows: [], skills: [],
    damageResistances: '', damageImmunities: '', conditionImmunities: '', damageVulnerabilities: '',
    senses: '', passivePerception: null, languages: '', tactics: '',
    initBonus: 0, initAdvantage: false, critRange: 20,
    attacks: [], // each: { name, bonus, note, desc, damages: [{ dice, type, note }] }
    multiattack: '',
    features: [],
    legendaryActionBudget: 0, legendaryActions: [], legendaryResistances: 0,
    lairActions: [], // each: { name, desc }
    source: '', gear: '',
    playerDescription: '', dmDescription: ''
  };
}

function newEncounter() {
  return { id: uuid(), name: '', location: '', campaign: '', notes: '', monsters: [] };
}

function newParty() {
  return { id: uuid(), name: '', players: [] };
}

// ═══════════════════════════════════════════════════════════════
// ── Storage (IndexedDB with localStorage fallback) ──
// ═══════════════════════════════════════════════════════════════

const DB_NAME = 'pf_encounter';
const DB_VERSION = 1;
const DB_STORE = 'state';
let _db = null;
let _useLocalStorage = false;

function openDB() {
  if (_db) return Promise.resolve(_db);
  return new Promise((resolve, reject) => {
    try {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = () => { req.result.createObjectStore(DB_STORE); };
      req.onsuccess = () => { _db = req.result; resolve(_db); };
      req.onerror = () => { reject(req.error); };
    } catch (e) { reject(e); }
  });
}

function idbGet(db, key) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, 'readonly');
    const req = tx.objectStore(DB_STORE).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function idbPut(key, value) {
  if (!_db) return;
  try {
    const tx = _db.transaction(DB_STORE, 'readwrite');
    tx.objectStore(DB_STORE).put(value, STORAGE_KEYS[key]);
  } catch (e) {
    console.error('IndexedDB write failed:', e);
  }
}

async function load() {
  try {
    const db = await openDB();
    let hasIdbData = false;
    for (const [key, skey] of Object.entries(STORAGE_KEYS)) {
      const val = await idbGet(db, skey);
      if (val !== undefined) { state[key] = val; hasIdbData = true; }
    }
    // Migrate old single combat → combats array (Phase 3.5 → Phase 4)
    const oldCombat = await idbGet(db, 'pf_enc_combat');
    if (oldCombat !== undefined) {
      state.combats = oldCombat ? [Object.assign({ id: oldCombat.id || uuid() }, oldCombat)] : [];
      try {
        const tx = _db.transaction(DB_STORE, 'readwrite');
        tx.objectStore(DB_STORE).put(state.combats, 'pf_enc_combats');
        tx.objectStore(DB_STORE).delete('pf_enc_combat');
      } catch (e) { /* best effort */ }
      console.log('Migrated single combat to combats array');
    }
    // Clean up old keys (Phase 4.1: shared player roster, Phase 4.4: dead groups field)
    try {
      const tx2 = _db.transaction(DB_STORE, 'readwrite');
      tx2.objectStore(DB_STORE).delete('pf_enc_players');
      tx2.objectStore(DB_STORE).delete('pf_enc_groups');
    } catch (e) { /* best effort */ }
    // Auto-migrate from localStorage if IndexedDB was empty
    if (!hasIdbData && oldCombat === undefined) {
      let migrated = false;
      // Check both old and new key names
      for (const [key, skey] of Object.entries(STORAGE_KEYS)) {
        try {
          const raw = localStorage.getItem(skey);
          if (raw) { state[key] = JSON.parse(raw); migrated = true; }
        } catch (e) { /* ignore parse errors */ }
      }
      // Also check old single-combat localStorage key
      try {
        const oldRaw = localStorage.getItem('pf_enc_combat');
        if (oldRaw) {
          const oldC = JSON.parse(oldRaw);
          state.combats = oldC ? [Object.assign({ id: oldC.id || uuid() }, oldC)] : [];
          migrated = true;
        }
      } catch (e) { /* ignore */ }
      if (migrated) {
        for (const [k, skey] of Object.entries(STORAGE_KEYS)) {
          try { _db.transaction(DB_STORE, 'readwrite').objectStore(DB_STORE).put(state[k], skey); } catch (e) { /* best effort */ }
        }
        for (const skey of [...Object.values(STORAGE_KEYS), 'pf_enc_combat', 'pf_enc_players', 'pf_enc_groups']) {
          try { localStorage.removeItem(skey); } catch (e) { /* best effort */ }
        }
        console.log('Migrated data from localStorage to IndexedDB');
      }
    }
  } catch (e) {
    console.warn('IndexedDB unavailable, falling back to localStorage:', e);
    _useLocalStorage = true;
    try {
      for (const [key, skey] of Object.entries(STORAGE_KEYS)) {
        const raw = localStorage.getItem(skey);
        if (raw) state[key] = JSON.parse(raw);
      }
      // Also check old single-combat key
      if (!state.combats.length) {
        const oldRaw = localStorage.getItem('pf_enc_combat');
        if (oldRaw) {
          const oldC = JSON.parse(oldRaw);
          state.combats = oldC ? [Object.assign({ id: oldC.id || uuid() }, oldC)] : [];
          localStorage.removeItem('pf_enc_combat');
        }
      }
    } catch (e2) {
      console.error('Failed to load state:', e2);
    }
  }
}

function save(key) {
  if (_useLocalStorage) {
    try {
      if (key) {
        localStorage.setItem(STORAGE_KEYS[key], JSON.stringify(state[key]));
      } else {
        for (const [k, skey] of Object.entries(STORAGE_KEYS)) {
          localStorage.setItem(skey, JSON.stringify(state[k]));
        }
      }
    } catch (e) {
      console.error('Failed to save state:', e);
      setStatus('Failed to save - storage may be full.', 'error');
    }
    return;
  }
  if (key) {
    idbPut(key, state[key]);
  } else {
    for (const [k] of Object.entries(STORAGE_KEYS)) {
      idbPut(k, state[k]);
    }
  }
  clearTimeout(save._storageTimer);
  save._storageTimer = setTimeout(updateStorageInfo, 2000);
}

// ═══════════════════════════════════════════════════════════════
// ── Dice Engine ──
// ═══════════════════════════════════════════════════════════════

function rollDice(notation, opts) {
  const mode = opts && opts.advantage ? ' adv' : opts && opts.disadvantage ? ' dis' : '';
  const result = rollDiceExpression(notation + mode);
  if (result.error) return { rolls: [], modifier: 0, total: 0, text: 'Invalid: ' + notation };
  return { rolls: result.rolls || [], modifier: 0, total: result.total, text: result.breakdown };
}

function renderDiceText(text, combatantIdx, sourceType, sourceIdx) {
  return text.replace(/(\d+d\d+(?:[+-]\d+)?)/gi, function(match) {
    let args = combatantIdx + ',\'' + match + '\'';
    if (sourceType !== undefined) args += ',\'' + sourceType + '\',' + sourceIdx;
    return '<span class="dice-link" onclick="event.stopPropagation();rollInlineDice(' + args + ')">' + match + '</span>';
  });
}

function rollInlineDice(combatantIdx, notation, sourceType, sourceIdx) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  if (!c.rollLog) c.rollLog = [];
  const result = rollDice(notation);
  let label = notation;
  if (sourceType && sourceIdx !== undefined) {
    const template = getTemplate(c);
    if (template) {
      if (sourceType === 'feature' && template.features[sourceIdx]) label = esc(template.features[sourceIdx].name) + ': ' + notation;
      else if (sourceType === 'la' && template.legendaryActions[sourceIdx]) label = esc(template.legendaryActions[sourceIdx].name) + ': ' + notation;
      else if (sourceType === 'attack' && template.attacks[sourceIdx]) label = esc(template.attacks[sourceIdx].name) + ': ' + notation;
      else if (sourceType === 'lair' && template.lairActions && template.lairActions[sourceIdx]) label = esc(template.lairActions[sourceIdx].name) + ': ' + notation;
    }
  }
  c.rollLog.push({ label: label, text: esc(result.text) + (result.text.indexOf('=') === -1 ? ' = ' + result.total : ''), cssClass: '' });
  saveCombat();
  renderRollLog(combatantIdx);
}

// ═══════════════════════════════════════════════════════════════
// ── Dice Expression Parser (general-purpose roller) ──
// ═══════════════════════════════════════════════════════════════

function parseDiceExpression(input) {
  let expr = (input || '').trim();
  if (!expr) return { ast: null, mode: null, error: 'Empty expression' };

  // Extract adv/dis suffix
  let mode = null;
  const suffixMatch = expr.match(/\s+(adv(?:antage)?|dis(?:advantage)?)\s*$/i);
  if (suffixMatch) {
    mode = suffixMatch[1].toLowerCase().startsWith('adv') ? 'advantage' : 'disadvantage';
    expr = expr.substring(0, suffixMatch.index);
  }

  // Strip all whitespace
  expr = expr.replace(/\s/g, '');
  if (!expr) return { ast: null, mode: mode, error: 'Empty expression' };

  // Tokenize
  const tokens = [];
  let i = 0;
  while (i < expr.length) {
    const ch = expr[i];
    if (ch >= '0' && ch <= '9') {
      let num = '';
      while (i < expr.length && expr[i] >= '0' && expr[i] <= '9') { num += expr[i]; i++; }
      tokens.push({ type: 'NUMBER', value: parseInt(num) });
    } else if (ch === 'd' || ch === 'D') {
      tokens.push({ type: 'D' }); i++;
    } else if (ch === '+') {
      tokens.push({ type: 'PLUS' }); i++;
    } else if (ch === '-') {
      tokens.push({ type: 'MINUS' }); i++;
    } else if (ch === '*') {
      tokens.push({ type: 'STAR' }); i++;
    } else if (ch === '/') {
      tokens.push({ type: 'SLASH' }); i++;
    } else if (ch === '(') {
      tokens.push({ type: 'LPAREN' }); i++;
    } else if (ch === ')') {
      tokens.push({ type: 'RPAREN' }); i++;
    } else {
      return { ast: null, mode: mode, error: 'Unexpected character: ' + ch };
    }
  }

  // Recursive descent parser
  let pos = 0;
  function peek() { return pos < tokens.length ? tokens[pos] : null; }
  function consume() { return tokens[pos++]; }

  function parseExpression() {
    let left = parseTerm();
    if (!left) return null;
    while (peek() && (peek().type === 'PLUS' || peek().type === 'MINUS')) {
      const op = consume().type === 'PLUS' ? '+' : '-';
      const right = parseTerm();
      if (!right) return null;
      left = { type: 'binop', op: op, left: left, right: right };
    }
    return left;
  }

  function parseTerm() {
    let left = parseFactor();
    if (!left) return null;
    while (peek() && (peek().type === 'STAR' || peek().type === 'SLASH')) {
      const op = consume().type === 'STAR' ? '*' : '/';
      const right = parseFactor();
      if (!right) return null;
      left = { type: 'binop', op: op, left: left, right: right };
    }
    return left;
  }

  function parseFactor() {
    const t = peek();
    if (!t) return null;

    // Parenthesized expression
    if (t.type === 'LPAREN') {
      consume();
      const inner = parseExpression();
      if (!inner) return null;
      if (!peek() || peek().type !== 'RPAREN') return null;
      consume();
      return { type: 'paren', inner: inner };
    }

    // Bare 'd' (e.g. d20 = 1d20)
    if (t.type === 'D') {
      consume();
      const sidesT = peek();
      if (!sidesT || sidesT.type !== 'NUMBER') return null;
      consume();
      return { type: 'dice', count: 1, sides: sidesT.value };
    }

    // Number, possibly followed by 'd' for dice
    if (t.type === 'NUMBER') {
      consume();
      if (peek() && peek().type === 'D') {
        consume();
        const sidesT2 = peek();
        if (!sidesT2 || sidesT2.type !== 'NUMBER') return null;
        consume();
        return { type: 'dice', count: t.value, sides: sidesT2.value };
      }
      return { type: 'number', value: t.value };
    }

    return null;
  }

  const ast = parseExpression();
  if (!ast || pos < tokens.length) {
    return { ast: null, mode: mode, error: 'Invalid expression' };
  }
  return { ast: ast, mode: mode, error: null };
}

function evalDiceNode(node, mode) {
  if (node.type === 'number') {
    return { value: node.value, text: String(node.value), hasDice: false, rolls: [], modeApplied: false };
  }

  if (node.type === 'dice') {
    const count = node.count;
    const sides = node.sides;
    if (count > 1000) return { value: 0, text: 'ERR:too many dice', hasDice: true, rolls: [], modeApplied: false };
    if (count === 0) return { value: 0, text: '0', hasDice: true, rolls: [], modeApplied: false };

    // Advantage/disadvantage for exactly 1d20
    if (count === 1 && sides === 20 && mode) {
      const r1 = Math.floor(Math.random() * 20) + 1;
      const r2 = Math.floor(Math.random() * 20) + 1;
      const pick = mode === 'advantage' ? Math.max(r1, r2) : Math.min(r1, r2);
      return { value: pick, text: '[' + r1 + ', ' + r2 + ']->' + pick, hasDice: true, rolls: [r1, r2], modeApplied: true };
    }

    const rolls = [];
    for (let i = 0; i < count; i++) rolls.push(Math.floor(Math.random() * sides) + 1);
    const sum = rolls.reduce(function(a, b) { return a + b; }, 0);

    let text;
    if (count === 1) {
      text = String(rolls[0]);
    } else if (count <= 10) {
      text = '[' + rolls.join(', ') + ']';
    } else {
      text = '(' + sum + ')';
    }
    return { value: sum, text: text, hasDice: true, rolls: rolls, modeApplied: false };
  }

  if (node.type === 'paren') {
    const inner = evalDiceNode(node.inner, mode);
    return { value: inner.value, text: '(' + inner.text + ')', hasDice: inner.hasDice, rolls: inner.rolls, modeApplied: inner.modeApplied };
  }

  if (node.type === 'binop') {
    const left = evalDiceNode(node.left, mode);
    const right = evalDiceNode(node.right, mode);
    let val;
    if (node.op === '+') val = left.value + right.value;
    else if (node.op === '-') val = left.value - right.value;
    else if (node.op === '*') val = left.value * right.value;
    else if (node.op === '/') {
      if (right.value === 0) return { value: 0, text: 'ERR:div/0', hasDice: true, rolls: left.rolls.concat(right.rolls), modeApplied: left.modeApplied || right.modeApplied };
      val = Math.floor(left.value / right.value);
    }

    const combinedRolls = left.rolls.concat(right.rolls);
    const combinedMode = left.modeApplied || right.modeApplied;

    // For * and /: if neither side has dice, collapse to computed value
    if ((node.op === '*' || node.op === '/') && !left.hasDice && !right.hasDice) {
      return { value: val, text: String(val), hasDice: false, rolls: combinedRolls, modeApplied: combinedMode };
    }

    const opStr = node.op === '*' ? ' * ' : node.op === '/' ? ' / ' : node.op === '-' ? ' - ' : ' + ';
    return { value: val, text: left.text + opStr + right.text, hasDice: left.hasDice || right.hasDice, rolls: combinedRolls, modeApplied: combinedMode };
  }

  return { value: 0, text: 'ERR', hasDice: false, rolls: [], modeApplied: false };
}

function rollDiceExpression(input) {
  const parsed = parseDiceExpression(input);
  if (parsed.error) return { error: parsed.error, input: input };

  const result = evalDiceNode(parsed.ast, parsed.mode);
  const total = Math.floor(result.value);
  const modeLabel = result.modeApplied ? (parsed.mode === 'advantage' ? ' (adv)' : ' (dis)') : '';
  const cleanInput = input.trim().replace(/\s+(adv(?:antage)?|dis(?:advantage)?)\s*$/i, '').replace(/\s/g, '');

  return {
    error: null,
    input: cleanInput + modeLabel,
    mode: parsed.mode,
    breakdown: result.text,
    total: total,
    rolls: result.rolls
  };
}

// ═══════════════════════════════════════════════════════════════
// ── Compression (SquishText-compatible) ──
// ═══════════════════════════════════════════════════════════════

const crcTable = new Uint32Array(256);
for (let i = 0; i < 256; i++) {
  let c = i;
  for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
  crcTable[i] = c;
}
function crc32(str) {
  let crc = 0xFFFFFFFF;
  for (let i = 0; i < str.length; i++) crc = crcTable[(crc ^ str.charCodeAt(i)) & 0xFF] ^ (crc >>> 8);
  return ((crc ^ 0xFFFFFFFF) >>> 0).toString(16).padStart(8, '0');
}

async function compress(text) {
  const encoder = new TextEncoder();
  const stream = new Blob([encoder.encode(text)])
    .stream()
    .pipeThrough(new CompressionStream('deflate-raw'));
  const blob = await new Response(stream).blob();
  const buffer = await blob.arrayBuffer();
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  const b64 = btoa(binary);
  return b64 + '.' + crc32(b64);
}

async function decompress(base64) {
  base64 = base64.replace(/^\[SquishText\][^\n]*\n?/, '');
  base64 = base64.trim().replace(/[\r\n\s]/g, '');
  base64 = base64.replace(/-/g, '+').replace(/_/g, '/');
  const dotIdx = base64.lastIndexOf('.');
  if (dotIdx > 0 && base64.length - dotIdx - 1 === 8) {
    const data = base64.slice(0, dotIdx);
    const checksum = base64.slice(dotIdx + 1).toLowerCase();
    if (crc32(data) !== checksum) throw new Error('Checksum mismatch - data may be corrupted.');
    base64 = data;
  }
  while (base64.length % 4 !== 0) base64 += '=';
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  const stream = new Blob([bytes])
    .stream()
    .pipeThrough(new DecompressionStream('deflate-raw'));
  const blob = await new Response(stream).blob();
  return await blob.text();
}

// ═══════════════════════════════════════════════════════════════
// ── Combat Helpers ──
// ═══════════════════════════════════════════════════════════════

function saveCombat() {
  save('combats');
  // Persist active combat ID so refreshes resume the same combat
  state.preferences = state.preferences || {};
  state.preferences.activeCombatId = activeCombatId;
  state.preferences.autoExpandedId = autoExpandedId;
  save('preferences');
}

function ensureArray(val) {
  if (Array.isArray(val)) return val;
  if (val && typeof val === 'object') {
    const arr = [];
    for (const k in val) {
      if (val.hasOwnProperty(k)) {
        const idx = parseInt(k);
        if (!isNaN(idx)) arr[idx] = val[k];
      }
    }
    return arr;
  }
  return [];
}

function getTemplate(c) {
  if (c.type !== 'monster') return null;
  const raw = state.templates.find(t => t.id === c.templateId);
  if (!raw) return null;
  const t = (c.overrides && Object.keys(c.overrides).length > 0) ? deepMerge(raw, c.overrides) : raw;
  // Safety: ensure array fields are arrays (guards against corrupted sparse-object overrides)
  t.savingThrows = ensureArray(t.savingThrows);
  t.skills = ensureArray(t.skills);
  t.attacks = ensureArray(t.attacks);
  t.features = ensureArray(t.features);
  t.legendaryActions = ensureArray(t.legendaryActions);
  t.lairActions = ensureArray(t.lairActions);
  return t;
}

function getRawTemplate(c) {
  return c.type === 'monster' ? state.templates.find(t => t.id === c.templateId) : null;
}

function deepMerge(base, overrides) {
  if (!overrides || typeof overrides !== 'object') return deepClone(base);
  if (!base || typeof base !== 'object') return deepClone(overrides);
  const result = {};
  for (const key in base) {
    if (!base.hasOwnProperty(key)) continue;
    if (!overrides.hasOwnProperty(key)) { result[key] = deepClone(base[key]); continue; }
    const bv = base[key], ov = overrides[key];
    if (Array.isArray(bv) && Array.isArray(ov)) {
      if (ov.length !== bv.length) {
        // Different length = full replacement (saves/skills add/remove)
        result[key] = deepClone(ov);
      } else {
        // Same length = index-based merge (attacks/features/LAs)
        result[key] = [];
        for (let i = 0; i < bv.length; i++) {
          if (ov[i] === null || ov[i] === undefined) {
            result[key][i] = deepClone(bv[i]);
          } else if (typeof ov[i] === 'object' && !Array.isArray(ov[i]) && typeof bv[i] === 'object' && !Array.isArray(bv[i])) {
            result[key][i] = deepMerge(bv[i], ov[i]);
          } else {
            result[key][i] = deepClone(ov[i]);
          }
        }
      }
    } else if (Array.isArray(bv) && !Array.isArray(ov) && typeof ov === 'object' && ov !== null) {
      // Sparse object override against array base (e.g. {"0": {bonus: 21}} vs [{ability:"str",bonus:20}])
      result[key] = [];
      for (let i = 0; i < bv.length; i++) {
        const sparseVal = ov[String(i)] !== undefined ? ov[String(i)] : ov[i];
        if (sparseVal === null || sparseVal === undefined) {
          result[key][i] = deepClone(bv[i]);
        } else if (typeof sparseVal === 'object' && !Array.isArray(sparseVal) && typeof bv[i] === 'object' && !Array.isArray(bv[i])) {
          result[key][i] = deepMerge(bv[i], sparseVal);
        } else {
          result[key][i] = deepClone(sparseVal);
        }
      }
    } else if (typeof bv === 'object' && !Array.isArray(bv) && bv !== null && typeof ov === 'object' && !Array.isArray(ov) && ov !== null) {
      result[key] = deepMerge(bv, ov);
    } else {
      result[key] = deepClone(ov);
    }
  }
  for (const key in overrides) {
    if (overrides.hasOwnProperty(key) && !base.hasOwnProperty(key)) {
      result[key] = deepClone(overrides[key]);
    }
  }
  return result;
}

function sparseOverrides(base, edited) {
  if (!base || !edited) return {};
  const result = {};
  let hasAny = false;
  for (const key in edited) {
    if (!edited.hasOwnProperty(key)) continue;
    const bv = base[key], ev = edited[key];
    if (Array.isArray(bv) && Array.isArray(ev)) {
      if (bv.length !== ev.length) {
        // Different length = full replacement
        result[key] = deepClone(ev);
        hasAny = true;
      } else {
        // Same length = sparse by index
        const sparse = [];
        let changed = false;
        for (let i = 0; i < bv.length; i++) {
          if (JSON.stringify(bv[i]) !== JSON.stringify(ev[i])) {
            if (typeof bv[i] === 'object' && !Array.isArray(bv[i]) && bv[i] !== null && typeof ev[i] === 'object' && !Array.isArray(ev[i]) && ev[i] !== null) {
              sparse[i] = sparseOverrides(bv[i], ev[i]);
            } else {
              sparse[i] = deepClone(ev[i]);
            }
            changed = true;
          } else {
            sparse[i] = null;
          }
        }
        if (changed) { result[key] = sparse; hasAny = true; }
      }
    } else if (typeof bv === 'object' && !Array.isArray(bv) && bv !== null && typeof ev === 'object' && !Array.isArray(ev) && ev !== null) {
      const sub = sparseOverrides(bv, ev);
      if (Object.keys(sub).length > 0) { result[key] = sub; hasAny = true; }
    } else if (JSON.stringify(bv) !== JSON.stringify(ev)) {
      result[key] = deepClone(ev);
      hasAny = true;
    }
  }
  return hasAny ? result : {};
}

function isFieldOverridden(c, fieldPath) {
  if (!c.overrides) return false;
  const parts = fieldPath.split('.');
  let obj = c.overrides;
  for (let i = 0; i < parts.length; i++) {
    if (obj === null || obj === undefined || typeof obj !== 'object') return false;
    const key = parts[i];
    if (Array.isArray(obj)) {
      const idx = parseInt(key);
      if (isNaN(idx) || obj[idx] === null || obj[idx] === undefined) return false;
      obj = obj[idx];
    } else {
      if (!obj.hasOwnProperty(key)) return false;
      obj = obj[key];
    }
  }
  return true;
}

// ═══════════════════════════════════════════════════════════════
// ── View Management ──
// ═══════════════════════════════════════════════════════════════

function switchView(view) {
  // Check for unsaved form changes before switching
  if (formState.mode && isFormDirty()) {
    if (!confirm('You have unsaved changes. Leave without saving?')) return;
  }
  formState.mode = null;
  formState.data = null;
  formState.savedSnapshot = null;
  searchQuery = '';
  // Clear edit mode state
  editState.mode = false;
  editState.selected = [];
  editState.lockedTemplateId = null;
  editState.formData = null;
  editState.visible = false;
  editState.rawTemplate = null;
  editState.formSnapshot = null;
  editState.conflicts.clear();

  currentView = view;
  state.preferences = state.preferences || {};
  state.preferences.view = view;
  state.preferences.activeCombatId = activeCombatId;
  save('preferences');
  ['templates', 'parties', 'encounters', 'combat'].forEach(v => {
    document.getElementById('nav' + v.charAt(0).toUpperCase() + v.slice(1)).classList.toggle('active', view === v);
    document.getElementById('view' + v.charAt(0).toUpperCase() + v.slice(1)).classList.toggle('active', view === v);
  });

  const btnNew = document.getElementById('btnNew');
  btnNew.style.display = view === 'combat' ? 'none' : '';
  const labels = { templates: '+ New Monster', parties: '+ New Party', encounters: '+ New Encounter' };
  btnNew.textContent = labels[view] || '';
  document.getElementById('btnImportMonster').style.display = view === 'templates' ? '' : 'none';

  render();
}

function handleNew() {
  if (currentView === 'templates') showTemplateForm(null);
  else if (currentView === 'parties') showPartyForm(null);
  else if (currentView === 'encounters') showEncounterForm(null);
}

function render() {
  if (currentView === 'templates') {
    if (formState.mode === 'template') renderTemplateForm();
    else renderTemplateList();
  } else if (currentView === 'parties') {
    if (formState.mode === 'party') renderPartyForm();
    else renderPartyList();
  } else if (currentView === 'encounters') {
    if (formState.mode === 'encounter') renderEncounterForm();
    else renderEncounterList();
  } else if (currentView === 'combat') {
    renderCombatView();
  }
}

// ═══════════════════════════════════════════════════════════════
// ── Template List ──
// ═══════════════════════════════════════════════════════════════

function renderTemplateList() {
  const el = document.getElementById('viewTemplates');
  document.getElementById('btnNew').style.display = '';

  const filtered = state.templates.filter(t =>
    !searchQuery || t.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  let html = '<div class="search-bar"><input type="text" placeholder="Search monsters..." value="' + esc(searchQuery) + '" oninput="searchQuery=this.value;renderTemplateList()"></div>';

  if (filtered.length === 0) {
    if (state.templates.length === 0) {
      html += '<div class="empty-state"><p>No monsters yet.</p><p>Click <strong>+ New Monster</strong> to create one.</p></div>';
    } else {
      html += '<div class="empty-state"><p>No monsters match your search.</p></div>';
    }
  } else {
    filtered.forEach(t => {
      const meta = [];
      if (t.size) meta.push(t.size);
      if (t.type) meta.push(t.type);
      if (t.alignment) meta.push(t.alignment);
      if (t.cr) meta.push('CR ' + t.cr);
      meta.push('AC ' + t.ac);
      meta.push(t.hpMax + ' HP');
      meta.push('PP ' + getPassivePerception(t));
      if (t.attacks.length) meta.push(t.attacks.length + ' attack' + (t.attacks.length > 1 ? 's' : ''));
      if (t.legendaryActionBudget > 0) meta.push('Legendary');

      html += '<div class="card">';
      html += '<div class="card-header">';
      html += '<span class="card-title">' + esc(t.name || 'Unnamed') + '</span>';
      html += '<div class="card-actions">';
      html += '<button class="btn-sm" onclick="showTemplateForm(\'' + t.id + '\')">Edit</button>';
      html += '<button class="btn-sm" onclick="exportMonster(\'' + t.id + '\')">Export</button>';
      html += '<button class="btn-sm btn-danger" onclick="deleteTemplate(\'' + t.id + '\')">Delete</button>';
      html += '</div></div>';
      html += '<div class="card-meta">' + meta.map(m => '<span>' + esc(m) + '</span>').join('') + '</div>';
      if (t.source || t.gear) {
        var extra = [];
        if (t.source) extra.push(t.source);
        if (t.gear) extra.push(t.gear);
        html += '<div style="font-size:0.7rem;color:var(--muted);margin-top:0.2rem">' + esc(extra.join(' · ')) + '</div>';
      }
      html += '</div>';
    });
  }

  el.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Template Form ──
// ═══════════════════════════════════════════════════════════════

function showTemplateForm(id) {
  formState.mode = 'template';
  if (id) {
    const t = state.templates.find(t => t.id === id);
    if (!t) { setStatus('Monster not found.', 'error'); return; }
    formState.data = deepClone(t);
  } else {
    formState.data = newTemplate();
  }
  formState.savedSnapshot = deepClone(formState.data);
  document.getElementById('btnNew').style.display = 'none';
  renderTemplateForm();
}

function renderTemplateForm() {
  const d = formState.data;
  const el = document.getElementById('viewTemplates');

  let html = '';

  // ── Basic Info ──
  html += '<div class="form-section"><div class="form-section-title">Basic Info</div>';
  html += '<div class="form-grid cols-4">';
  html += formField('Name', 'text', d.name, 'formState.data.name=this.value', 'Goblin');
  html += formField('Size', 'select', d.size, 'formState.data.size=this.value', null, SIZES);
  html += formField('Type', 'text', d.type, 'formState.data.type=this.value', 'Humanoid');
  html += formField('Alignment', 'text', d.alignment, 'formState.data.alignment=this.value', 'Unaligned');
  html += '</div>';
  html += '<div class="form-grid cols-4" style="margin-top:0.5rem">';
  html += formField('AC', 'number', d.ac, 'formState.data.ac=+this.value');
  html += formField('AC Note', 'text', d.acNote, 'formState.data.acNote=this.value', 'natural armor');
  html += formField('HP Max', 'number', d.hpMax, 'formState.data.hpMax=+this.value');
  html += '<div class="form-field"><label>HP Formula</label><div style="display:flex;gap:0.3rem"><input type="text" value="' + esc(d.hpFormula) + '" onchange="formState.data.hpFormula=this.value" placeholder="2d6" style="flex:1"><button class="btn-sm" onclick="hpFromFormula(\'avg\')" title="Set HP Max to formula average">Avg</button><button class="btn-sm" onclick="hpFromFormula(\'roll\')" title="Roll HP from formula">Roll</button></div></div>';
  html += '</div>';
  html += '<div class="form-grid cols-4" style="margin-top:0.5rem">';
  html += formField('Speed', 'text', d.speed, 'formState.data.speed=this.value', '30 ft.');
  html += formField('CR', 'text', d.cr, 'formState.data.cr=this.value', '1/4');
  html += formField('Init Bonus', 'number', d.initBonus, 'formState.data.initBonus=+this.value');
  html += '<div class="form-field"><label class="checkbox-label"><input type="checkbox" ' + (d.initAdvantage ? 'checked' : '') + ' onchange="formState.data.initAdvantage=this.checked"> Init Advantage</label></div>';
  html += '</div>';
  html += '<div class="form-grid cols-2" style="margin-top:0.5rem">';
  html += formField('Source', 'text', d.source || '', 'formState.data.source=this.value', 'MM 2014 p166');
  html += formField('Gear', 'text', d.gear || '', 'formState.data.gear=this.value', 'chain shirt, shield, scimitar');
  html += '</div></div>';

  // ── Ability Scores ──
  html += '<div class="form-section"><div class="form-section-title">Ability Scores</div>';
  html += '<div class="form-grid cols-6">';
  ABILITIES.forEach(ab => {
    const score = d.abilities[ab];
    html += '<div class="form-field"><label>' + ab.toUpperCase() + ' (<span id="mod_' + ab + '">' + modStr(score) + '</span>)</label>';
    const extra = ab === 'wis' ? ';updatePPDisplay()' : '';
    html += '<input type="number" value="' + score + '" onchange="formState.data.abilities.' + ab + '=+this.value;document.getElementById(\'mod_' + ab + '\').textContent=modStr(+this.value)' + extra + '">';
    html += '</div>';
  });
  html += '</div></div>';

  // ── Saving Throws ──
  html += '<div class="form-section"><div class="form-section-title">Saving Throws</div>';
  d.savingThrows.forEach((st, i) => {
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    html += '<div class="dyn-row">';
    html += '<select onchange="formState.data.savingThrows[' + i + '].ability=this.value" style="width:120px">';
    ABILITIES.forEach(ab => {
      html += '<option value="' + ab + '"' + (st.ability === ab ? ' selected' : '') + '>' + ABILITY_NAMES[ab] + '</option>';
    });
    html += '</select>';
    html += '<input type="number" value="' + st.bonus + '" onchange="formState.data.savingThrows[' + i + '].bonus=+this.value" style="width:60px" placeholder="+0">';
    html += '<button class="btn-remove" onclick="formState.data.savingThrows.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
    html += '</div>';
  });
  html += '<button class="btn-add-row" onclick="formState.data.savingThrows.push({ability:\'str\',bonus:0});renderTemplateForm()">+ Add Save</button>';
  html += '</div>';

  // ── Skills ──
  html += '<div class="form-section"><div class="form-section-title">Skills</div>';
  d.skills.forEach((sk, i) => {
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    html += '<div class="dyn-row">';
    html += '<select onchange="formState.data.skills[' + i + '].name=this.value" style="width:150px">';
    SKILLS.forEach(s => {
      html += '<option value="' + s + '"' + (sk.name === s ? ' selected' : '') + '>' + s + '</option>';
    });
    html += '</select>';
    html += '<input type="number" value="' + sk.bonus + '" onchange="formState.data.skills[' + i + '].bonus=+this.value" style="width:60px" placeholder="+0">';
    html += '<button class="btn-remove" onclick="formState.data.skills.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
    html += '</div>';
  });
  html += '<button class="btn-add-row" onclick="formState.data.skills.push({name:\'Perception\',bonus:0});renderTemplateForm()">+ Add Skill</button>';
  html += '</div>';

  // ── Defenses ──
  html += '<div class="form-section"><div class="form-section-title">Defenses & Senses</div>';
  html += '<div class="form-grid cols-2">';
  html += formField('Damage Resistances', 'text', d.damageResistances, 'formState.data.damageResistances=this.value', 'fire, cold');
  html += formField('Damage Immunities', 'text', d.damageImmunities, 'formState.data.damageImmunities=this.value', 'poison');
  html += formField('Damage Vulnerabilities', 'text', d.damageVulnerabilities, 'formState.data.damageVulnerabilities=this.value', 'radiant');
  html += formField('Condition Immunities', 'text', d.conditionImmunities, 'formState.data.conditionImmunities=this.value', 'frightened');
  html += formField('Senses', 'text', d.senses, 'formState.data.senses=this.value', 'darkvision 60 ft.');
  html += formField('Languages', 'text', d.languages, 'formState.data.languages=this.value', 'Common, Goblin');
  html += '</div>';
  html += '<div class="form-grid cols-2" style="margin-top:0.5rem">';
  html += '<div class="form-field"><label>Passive Perception (auto: <span id="pp_auto">' + calcPassivePerception(d) + '</span>)</label>';
  html += '<input type="number" id="pp_input" value="' + (d.passivePerception != null ? d.passivePerception : '') + '" onchange="formState.data.passivePerception=this.value===\'\'?null:+this.value;updatePPDisplay()" placeholder="' + calcPassivePerception(d) + '">';
  html += '</div>';
  html += '<div class="form-field"></div>';
  html += '</div></div>';

  // ── Attacks ──
  html += '<div class="form-section"><div class="form-section-title">Attacks</div>';
  html += '<div class="form-grid cols-2">';
  html += formField('Multiattack', 'text', d.multiattack, 'formState.data.multiattack=this.value', 'Two claw attacks');
  html += formField('Crits On', 'number', d.critRange || 20, 'formState.data.critRange=+this.value||20', '20');
  html += '</div>';
  html += '<div style="margin-top:0.5rem">';
  d.attacks.forEach((a, i) => {
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    // Attack header row: name, bonus, note, remove
    if (i === 0) {
      html += '<div class="dyn-header">';
      html += '<span class="dyn-label" style="flex:2">Name</span>';
      html += '<span class="dyn-label" style="width:55px">Hit</span>';
      html += '<span class="dyn-label" style="flex:1">Note</span>';
      html += '<span style="width:30px"></span>';
      html += '</div>';
    }
    html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
    html += '<input type="text" value="' + esc(a.name) + '" onchange="formState.data.attacks[' + i + '].name=this.value" placeholder="Scimitar" style="flex:2">';
    html += '<input type="number" value="' + a.bonus + '" onchange="formState.data.attacks[' + i + '].bonus=+this.value" placeholder="+4" style="width:55px">';
    html += '<input type="text" value="' + esc(a.note || '') + '" onchange="formState.data.attacks[' + i + '].note=this.value" placeholder="reach 10ft" style="flex:1">';
    html += '<button class="btn-remove" onclick="formState.data.attacks.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
    // Damage rows
    if (a.damages && a.damages.length > 0) {
      html += '<div style="padding-left:0.75rem;border-left:2px solid var(--border)">';
      html += '<div class="dyn-header">';
      html += '<span class="dyn-label" style="width:80px">Damage</span>';
      html += '<span class="dyn-label" style="width:80px">Type</span>';
      html += '<span class="dyn-label" style="flex:1">Note</span>';
      html += '<span style="width:30px"></span>';
      html += '</div>';
      a.damages.forEach((dm, j) => {
        html += '<div class="dyn-row">';
        html += '<input type="text" value="' + esc(dm.dice) + '" onchange="formState.data.attacks[' + i + '].damages[' + j + '].dice=this.value" placeholder="1d8+2" style="width:80px" title="Damage dice">';
        html += '<input type="text" value="' + esc(dm.type) + '" onchange="formState.data.attacks[' + i + '].damages[' + j + '].type=this.value" placeholder="slashing" style="width:80px" title="Damage type">';
        html += '<input type="text" value="' + esc(dm.note || '') + '" onchange="formState.data.attacks[' + i + '].damages[' + j + '].note=this.value" placeholder="note" style="flex:1" title="Damage note">';
        html += '<button class="btn-remove" onclick="formState.data.attacks[' + i + '].damages.splice(' + j + ',1);renderTemplateForm()">×</button>';
        html += '</div>';
      });
      html += '</div>';
    }
    html += '<button class="btn-add-row btn-sm" onclick="formState.data.attacks[' + i + '].damages.push({dice:\'\',type:\'\',note:\'\'});renderTemplateForm()" style="margin-left:0.75rem">+ Damage</button>';
    html += '<div class="dyn-row" style="margin-top:0.5rem"><textarea onchange="formState.data.attacks[' + i + '].desc=this.value" placeholder="Special effects, conditions, additional details..." style="width:100%">' + esc(a.desc || '') + '</textarea></div>';
    html += '</div>';
  });
  html += '</div>';
  html += '<button class="btn-add-row" onclick="formState.data.attacks.push({name:\'\',bonus:0,note:\'\',desc:\'\',damages:[{dice:\'\',type:\'\',note:\'\'}]});renderTemplateForm()">+ Add Attack</button>';
  html += '</div>';

  // ── Features ──
  html += '<div class="form-section"><div class="form-section-title">Features & Abilities</div>';
  d.features.forEach((f, i) => {
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    if (i === 0) {
      html += '<div class="dyn-header">';
      html += '<span class="dyn-label" style="flex:2">Name</span>';
      html += '<span class="dyn-label" style="width:100px">Recharge</span>';
      html += '<span class="dyn-label" style="width:55px">Uses</span>';
      html += '<span style="width:30px"></span>';
      html += '</div>';
    }
    html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
    html += '<input type="text" value="' + esc(f.name) + '" onchange="formState.data.features[' + i + '].name=this.value" placeholder="Feature name" style="flex:2">';
    html += '<input type="text" value="' + esc(f.recharge || '') + '" onchange="formState.data.features[' + i + '].recharge=this.value||null" placeholder="5-6" style="width:100px">';
    html += '<input type="number" value="' + (f.usesMax || '') + '" onchange="formState.data.features[' + i + '].usesMax=+this.value||null;formState.data.features[' + i + '].uses=+this.value||null" placeholder="#" style="width:55px">';
    html += '<button class="btn-remove" onclick="formState.data.features.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
    html += '<div class="dyn-row"><textarea onchange="formState.data.features[' + i + '].desc=this.value" placeholder="Description..." style="width:100%">' + esc(f.desc) + '</textarea></div>';
    html += '</div>';
  });
  html += '<button class="btn-add-row" onclick="formState.data.features.push({name:\'\',desc:\'\',recharge:null,uses:null,usesMax:null});renderTemplateForm()">+ Add Feature</button>';
  html += '</div>';

  // ── Legendary ──
  html += '<div class="form-section"><div class="form-section-title">Legendary</div>';
  html += '<div class="form-grid cols-2">';
  html += formField('Actions/Round', 'number', d.legendaryActionBudget, 'formState.data.legendaryActionBudget=+this.value');
  html += formField('Resistances', 'number', d.legendaryResistances, 'formState.data.legendaryResistances=+this.value');
  html += '</div>';
  html += '<div style="margin-top:0.5rem">';
  d.legendaryActions.forEach((la, i) => {
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    if (i === 0) {
      html += '<div class="dyn-header">';
      html += '<span class="dyn-label" style="flex:2">Name</span>';
      html += '<span class="dyn-label" style="width:55px">Cost</span>';
      html += '<span style="width:30px"></span>';
      html += '</div>';
    }
    html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
    html += '<input type="text" value="' + esc(la.name) + '" onchange="formState.data.legendaryActions[' + i + '].name=this.value" placeholder="Action name" style="flex:2">';
    html += '<input type="number" value="' + la.cost + '" onchange="formState.data.legendaryActions[' + i + '].cost=+this.value" placeholder="#" style="width:55px">';
    html += '<button class="btn-remove" onclick="formState.data.legendaryActions.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
    html += '<div class="dyn-row"><textarea onchange="formState.data.legendaryActions[' + i + '].desc=this.value" placeholder="Description..." style="width:100%">' + esc(la.desc) + '</textarea></div>';
    html += '</div>';
  });
  html += '<button class="btn-add-row" onclick="formState.data.legendaryActions.push({name:\'\',cost:1,desc:\'\'});renderTemplateForm()">+ Add Legendary Action</button>';
  html += '</div>';
  html += '</div>';

  // ── Lair Actions ──
  html += '<div class="form-section"><div class="form-section-title">Lair Actions</div>';
  if (d.lairActions && d.lairActions.length > 0) {
    d.lairActions.forEach((la, i) => {
      html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
      if (i === 0) {
        html += '<div class="dyn-header">';
        html += '<span class="dyn-label" style="flex:2">Name</span>';
        html += '<span style="width:30px"></span>';
        html += '</div>';
      }
      html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
      html += '<input type="text" value="' + esc(la.name) + '" onchange="formState.data.lairActions[' + i + '].name=this.value" placeholder="Lair action name" style="flex:2">';
      html += '<button class="btn-remove" onclick="formState.data.lairActions.splice(' + i + ',1);renderTemplateForm()">×</button>';
      html += '</div>';
      html += '<div class="dyn-row"><textarea onchange="formState.data.lairActions[' + i + '].desc=this.value" placeholder="Description..." style="width:100%">' + esc(la.desc || '') + '</textarea></div>';
      html += '</div>';
    });
  }
  html += '<button class="btn-add-row" onclick="if(!formState.data.lairActions)formState.data.lairActions=[];formState.data.lairActions.push({name:\'\',desc:\'\'});renderTemplateForm()">+ Add Lair Action</button>';
  html += '</div>';

  // ── Tactics ──
  html += '<div class="form-section"><div class="form-section-title">Tactics & Notes</div>';
  html += '<div class="form-field"><textarea rows="3" onchange="formState.data.tactics=this.value" placeholder="How this monster fights: target priority, positioning, retreat conditions...">' + esc(d.tactics) + '</textarea>';
  html += '</div></div>';

  // ── Descriptions ──
  html += '<div class="form-section"><div class="form-section-title">Descriptions</div>';
  html += '<div class="form-field"><label>Player Description</label>';
  html += '<textarea rows="3" onchange="formState.data.playerDescription=this.value" placeholder="What players see: appearance, sounds, smells - read aloud or reference when asked...">' + esc(d.playerDescription || '') + '</textarea>';
  html += '</div>';
  html += '<div class="form-field"><label>DM Description</label>';
  html += '<textarea rows="3" onchange="formState.data.dmDescription=this.value" placeholder="Lore, behavior, SRD reference text, background info...">' + esc(d.dmDescription || '') + '</textarea>';
  html += '</div></div>';

  // ── Form Actions ──
  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="saveTemplate()">Save</button>';
  html += '<button onclick="closeTemplateForm()">Close</button>';
  html += '<button class="btn-danger" onclick="cancelTemplateForm()">Cancel</button>';
  html += '</div>';

  el.innerHTML = html;
  el.scrollTop = 0;
}

function formField(label, type, value, onchange, placeholder, options) {
  let html = '<div class="form-field"><label>' + esc(label) + '</label>';
  if (type === 'select') {
    html += '<select onchange="' + onchange + '">';
    (options || []).forEach(opt => {
      html += '<option value="' + esc(opt) + '"' + (value === opt ? ' selected' : '') + '>' + esc(opt) + '</option>';
    });
    html += '</select>';
  } else if (type === 'number') {
    html += '<input type="number" value="' + (value ?? '') + '" onchange="' + onchange + '"' + (placeholder ? ' placeholder="' + esc(placeholder) + '"' : '') + '>';
  } else {
    html += '<input type="text" value="' + esc(value || '') + '" onchange="' + onchange + '"' + (placeholder ? ' placeholder="' + esc(placeholder) + '"' : '') + '>';
  }
  html += '</div>';
  return html;
}

function hpFromFormula(mode) {
  const formula = formState.data.hpFormula.trim();
  if (!formula) { setStatus('Enter an HP formula first.', 'warning'); return; }
  const match = formula.match(/^(\d+)d(\d+)\s*([+-]\s*\d+)?$/i);
  if (!match) { setStatus('Invalid formula: ' + formula, 'error'); return; }
  const count = parseInt(match[1]);
  const sides = parseInt(match[2]);
  const modifier = match[3] ? parseInt(match[3].replace(/\s/g, '')) : 0;

  if (mode === 'avg') {
    const avg = Math.floor(count * (sides + 1) / 2) + modifier;
    formState.data.hpMax = Math.max(1, avg);
    setStatus('HP set to average: ' + formState.data.hpMax, 'success');
  } else {
    const result = rollDice(formula);
    formState.data.hpMax = Math.max(1, result.total);
    setStatus('HP rolled: ' + result.text, 'success');
  }
  renderTemplateForm();
}

function saveTemplate() {
  if (!formState.data.name.trim()) {
    setStatus('Monster name is required.', 'error');
    return;
  }
  const idx = state.templates.findIndex(t => t.id === formState.data.id);
  if (idx >= 0) {
    state.templates[idx] = deepClone(formState.data);
    setStatus('Monster saved: ' + formState.data.name, 'success');
  } else {
    state.templates.push(deepClone(formState.data));
    setStatus('Monster saved: ' + formState.data.name, 'success');
  }
  save('templates');
  formState.savedSnapshot = deepClone(formState.data);
}

function closeTemplateForm() {
  if (isFormDirty()) {
    if (!confirm('You have unsaved changes. Close without saving?')) return;
  }
  formState.mode = null;
  formState.data = null;
  formState.savedSnapshot = null;
  setStatus('', '');
  render();
}

function cancelTemplateForm() {
  if (isFormDirty()) {
    if (!confirm('Discard all changes?')) return;
  }
  formState.mode = null;
  formState.data = null;
  formState.savedSnapshot = null;
  setStatus('', '');
  render();
}

function deleteTemplate(id) {
  const t = state.templates.find(t => t.id === id);
  if (!t) return;
  if (!confirm('Delete "' + t.name + '"? This cannot be undone.')) return;
  state.templates = state.templates.filter(t => t.id !== id);
  save('templates');
  setStatus('Deleted: ' + t.name, 'warning');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Encounter List ──
// ═══════════════════════════════════════════════════════════════

function renderEncounterList() {
  const el = document.getElementById('viewEncounters');
  document.getElementById('btnNew').style.display = '';

  const filtered = state.encounters.filter(e =>
    !searchQuery || e.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    (e.campaign && e.campaign.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  let html = '<div class="search-bar"><input type="text" placeholder="Search encounters..." value="' + esc(searchQuery) + '" oninput="searchQuery=this.value;renderEncounterList()"></div>';

  if (filtered.length === 0) {
    if (state.encounters.length === 0) {
      html += '<div class="empty-state"><p>No encounters yet.</p><p>Click <strong>+ New Encounter</strong> to build one.</p></div>';
    } else {
      html += '<div class="empty-state"><p>No encounters match your search.</p></div>';
    }
  } else {
    filtered.forEach(e => {
      const meta = [];
      if (e.campaign) meta.push(e.campaign);
      if (e.location) meta.push(e.location);
      const totalMonsters = e.monsters.reduce((sum, m) => sum + m.qty, 0);
      if (totalMonsters) meta.push(totalMonsters + ' monster' + (totalMonsters > 1 ? 's' : ''));

      html += '<div class="card">';
      html += '<div class="card-header">';
      html += '<span class="card-title">' + esc(e.name || 'Unnamed') + '</span>';
      html += '<div class="card-actions">';
      html += '<button class="btn-sm btn-action" onclick="startCombat(\'' + e.id + '\')" title="Start combat">Combat</button>';
      html += '<button class="btn-sm" onclick="showEncounterForm(\'' + e.id + '\')">Edit</button>';
      html += '<button class="btn-sm btn-danger" onclick="deleteEncounter(\'' + e.id + '\')">Delete</button>';
      html += '</div></div>';
      html += '<div class="card-meta">' + meta.map(m => '<span>' + esc(m) + '</span>').join('') + '</div>';
      html += '</div>';
    });
  }

  el.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Encounter Form ──
// ═══════════════════════════════════════════════════════════════

function showEncounterForm(id) {
  formState.mode = 'encounter';
  if (id) {
    const e = state.encounters.find(e => e.id === id);
    if (!e) { setStatus('Encounter not found.', 'error'); return; }
    formState.data = deepClone(e);
  } else {
    formState.data = newEncounter();
  }
  formState.savedSnapshot = deepClone(formState.data);
  document.getElementById('btnNew').style.display = 'none';
  renderEncounterForm();
}

function renderEncounterForm() {
  const d = formState.data;
  const el = document.getElementById('viewEncounters');

  let html = '';

  // ── Details ──
  html += '<div class="form-section"><div class="form-section-title">Encounter Details</div>';
  html += '<div class="form-grid cols-3">';
  html += formField('Name *', 'text', d.name, 'formState.data.name=this.value', 'Ambush at Cragmaw');
  html += formField('Campaign', 'text', d.campaign, 'formState.data.campaign=this.value', 'Lost Mines');
  html += formField('Location', 'text', d.location, 'formState.data.location=this.value', 'Forest Road');
  html += '</div>';
  html += '<div style="margin-top:0.5rem">';
  html += '<div class="form-field"><label>Notes</label>';
  html += '<textarea onchange="formState.data.notes=this.value" placeholder="Encounter notes...">' + esc(d.notes) + '</textarea>';
  html += '</div></div></div>';

  // ── Monsters ──
  html += '<div class="form-section"><div class="form-section-title">Monsters</div>';
  if (state.templates.length === 0) {
    html += '<p style="font-size:0.8rem;color:var(--text-dim)">No monsters yet. Create some in the Monsters tab first.</p>';
  } else {
    html += '<div style="display:flex;gap:0.4rem;margin-bottom:0.5rem;align-items:flex-start">';
    html += '<div class="search-select">';
    html += '<input type="text" id="monsterPicker" placeholder="Search monsters..." autocomplete="off" oninput="filterMonsterPicker(this.value)" onfocus="filterMonsterPicker(this.value)" style="width:100%;padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem;box-sizing:border-box">';
    html += '<div id="monsterPickerDropdown" class="search-dropdown"></div>';
    html += '</div>';
    html += '<input type="number" id="monsterQty" value="1" min="1" max="20" style="width:55px;padding:0.4rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem;font-family:var(--mono);text-align:center">';
    html += '<button class="btn-sm" onclick="addMonsterToEncounter()">Add</button>';
    html += '</div>';
  }
  d.monsters.forEach((m, i) => {
    const t = state.templates.find(t => t.id === m.templateId);
    html += '<div class="monster-pick">';
    html += '<span class="pick-name">' + esc(t ? t.name : '(deleted template)') + '</span>';
    html += '<input type="number" class="pick-qty" value="' + m.qty + '" min="1" max="20" onchange="formState.data.monsters[' + i + '].qty=+this.value">';
    html += '<button class="btn-sm btn-remove" onclick="formState.data.monsters.splice(' + i + ',1);renderEncounterForm()">×</button>';
    html += '</div>';
  });
  html += '</div>';

  // ── Form Actions ──
  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="saveEncounter()">Save</button>';
  html += '<button onclick="closeEncounterForm()">Close</button>';
  html += '<button class="btn-danger" onclick="cancelEncounterForm()">Cancel</button>';
  html += '</div>';

  el.innerHTML = html;
  el.scrollTop = 0;
}

function addMonsterToEncounter() {
  const input = document.getElementById('monsterPicker');
  const qtyInput = document.getElementById('monsterQty');
  if (!input) return;
  const templateId = input.dataset.templateId;
  if (!templateId) { setStatus('Select a monster first.', 'warning'); return; }
  const qty = Math.max(1, parseInt(qtyInput.value) || 1);

  // Check if already added - increment qty instead
  const existing = formState.data.monsters.find(m => m.templateId === templateId);
  if (existing) {
    existing.qty += qty;
  } else {
    formState.data.monsters.push({ templateId, qty });
  }
  input.value = '';
  input.dataset.templateId = '';
  renderEncounterForm();
}

function filterMonsterPicker(query) {
  const dropdown = document.getElementById('monsterPickerDropdown');
  if (!dropdown) return;
  const q = query.toLowerCase();
  const matches = state.templates.filter(t => t.name.toLowerCase().includes(q));
  if (matches.length === 0) {
    dropdown.innerHTML = '<div class="search-dropdown-item" style="color:var(--text-dim);cursor:default">No matches</div>';
  } else {
    dropdown.innerHTML = matches.map(t =>
      '<div class="search-dropdown-item" onmousedown="selectMonster(\'' + t.id + '\')">' + esc(t.name) + '<span class="cr-tag">CR ' + esc(t.cr || '?') + '</span></div>'
    ).join('');
  }
  dropdown.classList.add('open');
}

function selectMonster(templateId) {
  const input = document.getElementById('monsterPicker');
  const dropdown = document.getElementById('monsterPickerDropdown');
  const t = state.templates.find(t => t.id === templateId);
  if (!input || !t) return;
  input.value = t.name;
  input.dataset.templateId = templateId;
  if (dropdown) dropdown.classList.remove('open');
}

document.addEventListener('click', function(e) {
  const dropdown = document.getElementById('monsterPickerDropdown');
  if (dropdown && !e.target.closest('.search-select')) dropdown.classList.remove('open');
});

function saveEncounter() {
  if (!formState.data.name.trim()) {
    setStatus('Encounter name is required.', 'error');
    return;
  }
  const idx = state.encounters.findIndex(e => e.id === formState.data.id);
  if (idx >= 0) {
    state.encounters[idx] = deepClone(formState.data);
    setStatus('Encounter saved: ' + formState.data.name, 'success');
  } else {
    state.encounters.push(deepClone(formState.data));
    setStatus('Encounter saved: ' + formState.data.name, 'success');
  }
  save('encounters');
  formState.savedSnapshot = deepClone(formState.data);
}

function closeEncounterForm() {
  if (isFormDirty()) {
    if (!confirm('You have unsaved changes. Close without saving?')) return;
  }
  formState.mode = null;
  formState.data = null;
  formState.savedSnapshot = null;
  setStatus('', '');
  render();
}

function cancelEncounterForm() {
  if (isFormDirty()) {
    if (!confirm('Discard all changes?')) return;
  }
  formState.mode = null;
  formState.data = null;
  formState.savedSnapshot = null;
  setStatus('', '');
  render();
}

function deleteEncounter(id) {
  const e = state.encounters.find(e => e.id === id);
  if (!e) return;
  if (!confirm('Delete encounter "' + e.name + '"?')) return;
  state.encounters = state.encounters.filter(e => e.id !== id);
  save('encounters');
  const hadCombats = state.combats.length;
  state.combats = state.combats.filter(c => c.encounterId !== id);
  if (state.combats.length !== hadCombats) {
    activeCombatId = null;
    pendingCombatEncounterId = null;
    saveCombat();
  }
  setStatus('Deleted: ' + e.name, 'warning');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Party List ──
// ═══════════════════════════════════════════════════════════════

function renderPartyList() {
  const el = document.getElementById('viewParties');
  document.getElementById('btnNew').style.display = '';

  let html = '';

  if (state.parties.length === 0) {
    html += '<div class="empty-state"><p>No parties yet.</p><p>Click <strong>+ New Party</strong> to create one.</p></div>';
  } else {
    state.parties.forEach(p => {
      html += '<div class="card">';
      html += '<div class="card-header">';
      html += '<span class="card-title">' + esc(p.name || 'Unnamed') + '</span>';
      html += '<div class="card-actions">';
      html += '<button class="btn-sm" onclick="showPartyForm(\'' + p.id + '\')">Edit</button>';
      html += '<button class="btn-sm btn-danger" onclick="deleteParty(\'' + p.id + '\')">Delete</button>';
      html += '</div></div>';
      html += '<div class="card-meta"><span>' + p.players.length + ' player' + (p.players.length !== 1 ? 's' : '') + '</span>';
      if (p.players.length > 0) html += '<span>' + p.players.map(n => esc(n)).join(', ') + '</span>';
      html += '</div>';
      html += '</div>';
    });
  }

  el.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Party Form ──
// ═══════════════════════════════════════════════════════════════

function showPartyForm(id) {
  formState.mode = 'party';
  if (id) {
    const p = state.parties.find(p => p.id === id);
    if (!p) { setStatus('Party not found.', 'error'); return; }
    formState.data = deepClone(p);
  } else {
    formState.data = newParty();
  }
  formState.savedSnapshot = deepClone(formState.data);
  document.getElementById('btnNew').style.display = 'none';
  renderPartyForm();
}

function renderPartyForm() {
  const d = formState.data;
  const el = document.getElementById('viewParties');

  let html = '';

  html += '<div class="form-section"><div class="form-section-title">Party Details</div>';
  html += '<div class="form-grid cols-2">';
  html += formField('Party Name *', 'text', d.name, 'formState.data.name=this.value', 'Tuesday Night Crew');
  html += '<div class="form-field"></div>';
  html += '</div></div>';

  // ── Players ──
  html += '<div class="form-section"><div class="form-section-title">Players</div>';
  html += '<div style="display:flex;gap:0.4rem;margin-bottom:0.5rem">';
  html += '<input type="text" id="newPlayerInput" placeholder="Player name" style="flex:1;padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem" onkeydown="if(event.key===\'Enter\')addPlayerToParty()">';
  html += '<button class="btn-sm" onclick="addPlayerToParty()">Add</button>';
  html += '</div>';

  if (d.players.length > 0) {
    html += '<div class="player-list">';
    d.players.forEach((p, idx) => {
      html += '<span class="player-chip">';
      html += esc(p);
      html += '<span class="chip-remove" onclick="removePlayerFromParty(' + idx + ')" title="Remove player">×</span>';
      html += '</span>';
    });
    html += '</div>';
  }
  html += '</div>';

  // ── Form Actions ──
  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="saveParty()">Save</button>';
  html += '<button onclick="closePartyForm()">Close</button>';
  html += '<button class="btn-danger" onclick="cancelPartyForm()">Cancel</button>';
  html += '</div>';

  el.innerHTML = html;
  el.scrollTop = 0;
}

function addPlayerToParty() {
  const input = document.getElementById('newPlayerInput');
  if (!input) return;
  const name = input.value.trim();
  if (!name) return;
  if (!formState.data.players.includes(name)) formState.data.players.push(name);
  renderPartyForm();
  const refocused = document.getElementById('newPlayerInput');
  if (refocused) refocused.focus();
}

function removePlayerFromParty(idx) {
  formState.data.players.splice(idx, 1);
  renderPartyForm();
}

function saveParty() {
  if (!formState.data.name.trim()) {
    setStatus('Party name is required.', 'error');
    return;
  }
  const idx = state.parties.findIndex(p => p.id === formState.data.id);
  if (idx >= 0) {
    state.parties[idx] = deepClone(formState.data);
    setStatus('Party saved: ' + formState.data.name, 'success');
  } else {
    state.parties.push(deepClone(formState.data));
    setStatus('Party saved: ' + formState.data.name, 'success');
  }
  save('parties');
  formState.savedSnapshot = deepClone(formState.data);
}

function closePartyForm() {
  if (isFormDirty()) {
    if (!confirm('You have unsaved changes. Close without saving?')) return;
  }
  formState.mode = null;
  formState.data = null;
  formState.savedSnapshot = null;
  setStatus('', '');
  render();
}

function cancelPartyForm() {
  if (isFormDirty()) {
    if (!confirm('Discard all changes?')) return;
  }
  formState.mode = null;
  formState.data = null;
  formState.savedSnapshot = null;
  setStatus('', '');
  render();
}

function deleteParty(id) {
  const p = state.parties.find(p => p.id === id);
  if (!p) return;
  if (!confirm('Delete party "' + p.name + '"?')) return;
  state.parties = state.parties.filter(p => p.id !== id);
  save('parties');
  setStatus('Deleted: ' + p.name, 'warning');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Combat View (Phase 2 placeholder) ──
// ═══════════════════════════════════════════════════════════════

function renderCombatView() {
  const el = document.getElementById('viewCombat');

  // Active combat selected?
  const active = getActiveCombat();
  if (active && active.active) {
    if (active.round === 0) {
      renderInitiativeSetup(el);
    } else {
      renderActiveCombat(el);
    }
    return;
  }

  // Starting a new combat?
  if (pendingCombatEncounterId) {
    el.innerHTML = renderCombatPartySelect();
    return;
  }

  // Have existing combats? Show combat list
  if (state.combats.length > 0) {
    renderCombatList(el);
    return;
  }

  el.innerHTML = '<div class="empty-state"><p>No active combats.</p><p>Go to <strong>Encounters</strong> and click <strong>Combat</strong> to start one.</p></div>';
}

function renderCombatList(el) {
  let html = '<div class="form-section">';
  html += '<div class="form-section-title">Active Combats</div>';
  state.combats.forEach(combat => {
    const enc = state.encounters.find(e => e.id === combat.encounterId);
    const currentName = combat.combatants[combat.turnIndex] ? combat.combatants[combat.turnIndex].name : '-';
    const alive = combat.combatants.filter(c => !c.dead).length;
    html += '<div class="combat-list-card" onclick="resumeCombat(\'' + combat.id + '\')">';
    html += '<div class="combat-list-name">' + esc(combat.name || (enc ? enc.name : 'Combat')) + '</div>';
    html += '<div class="combat-list-info">';
    if (combat.round === 0) {
      html += '<span class="round-badge" style="font-size:0.65rem;padding:0.15rem 0.4rem">Setup</span>';
    } else {
      html += '<span class="round-badge" style="font-size:0.65rem;padding:0.15rem 0.4rem">Round ' + combat.round + '</span>';
      html += '<span style="font-size:0.75rem;color:var(--text-dim)">Turn: ' + esc(currentName) + '</span>';
    }
    html += '<span style="font-size:0.75rem;color:var(--text-dim)">' + alive + '/' + combat.combatants.length + ' alive</span>';
    html += '</div>';
    const players = combat.combatants.filter(c => c.type === 'player');
    if (players.length > 0) {
      html += '<div style="font-size:0.72rem;color:var(--text-muted);margin-top:0.25rem">' + players.map(p => esc(p.name)).join(', ') + '</div>';
    }
    html += '</div>';
  });
  html += '</div>';
  el.innerHTML = html;
}

function resumeCombat(combatId) {
  activeCombatId = combatId;
  state.preferences = state.preferences || {};
  state.preferences.activeCombatId = activeCombatId;
  save('preferences');
  render();
}

let pendingCombatEncounterId = null;

function startCombat(encounterId) {
  const enc = state.encounters.find(e => e.id === encounterId);
  if (!enc) { setStatus('Encounter not found.', 'error'); return; }
  if (enc.monsters.length === 0) {
    setStatus('Add monsters to the encounter first.', 'warning');
    return;
  }
  if (state.parties.length === 0) {
    setStatus('Create a party in the Parties tab first.', 'warning');
    return;
  }
  pendingCombatEncounterId = encounterId;
  activeCombatId = null;
  switchView('combat');
}

function renderCombatPartySelect() {
  const enc = state.encounters.find(e => e.id === pendingCombatEncounterId);
  if (!enc) return '<div class="empty-state"><p>Encounter not found.</p></div>';

  let html = '<div class="form-section"><div class="form-section-title">Start Combat: ' + esc(enc.name) + '</div>';
  const totalMonsters = enc.monsters.reduce((sum, m) => sum + m.qty, 0);
  html += '<p style="font-size:0.8rem;color:var(--text-muted);margin-bottom:1rem">' + totalMonsters + ' monster' + (totalMonsters > 1 ? 's' : '') + (enc.location ? ' at ' + esc(enc.location) : '') + '</p>';
  html += '<div class="form-section-title">Select Party</div>';

  state.parties.forEach(p => {
    html += '<div class="card" style="cursor:pointer" onclick="launchCombat(\'' + p.id + '\')">';
    html += '<div class="card-header">';
    html += '<span class="card-title">' + esc(p.name || 'Unnamed') + '</span>';
    html += '<button class="btn-sm btn-action">Select</button>';
    html += '</div>';
    html += '<div class="card-meta"><span>' + p.players.length + ' player' + (p.players.length !== 1 ? 's' : '') + '</span><span>' + esc(p.players.join(', ')) + '</span></div>';
    html += '</div>';
  });

  html += '<div style="margin-top:1rem"><button onclick="pendingCombatEncounterId=null;render()">Cancel</button></div>';
  html += '</div>';
  return html;
}

function createMonsterCombatant(template, name) {
  const bonus = template.initBonus || 0;
  const notation = '1d20' + (bonus >= 0 ? '+' + bonus : String(bonus));
  const initRoll = rollDice(notation, { advantage: template.initAdvantage });
  return {
    id: uuid(),
    templateId: template.id,
    name: name,
    type: 'monster',
    init: initRoll.total,
    initRollText: initRoll.text,
    currentHp: template.hpMax
  };
}

function getExistingMonsterCount(combat, templateId) {
  return combat.combatants.filter(c => c.templateId === templateId).length;
}

function launchCombat(partyId) {
  const party = state.parties.find(p => p.id === partyId);
  const enc = state.encounters.find(e => e.id === pendingCombatEncounterId);
  if (!party || !enc) { setStatus('Party or encounter not found.', 'error'); return; }

  const combatants = [];

  // Pre-count per templateId for numbering across duplicate entries
  const templateCounts = {};
  enc.monsters.forEach(m => {
    templateCounts[m.templateId] = (templateCounts[m.templateId] || 0) + m.qty;
  });
  const templateCounters = {};

  // Create monster instances
  enc.monsters.forEach(m => {
    const template = state.templates.find(t => t.id === m.templateId);
    if (!template) return;
    const total = templateCounts[m.templateId];
    if (!templateCounters[m.templateId]) templateCounters[m.templateId] = 0;

    for (let i = 0; i < m.qty; i++) {
      templateCounters[m.templateId]++;
      const num = templateCounters[m.templateId];
      const name = total > 1 ? template.name + ' ' + num : template.name;
      combatants.push(createMonsterCombatant(template, name));
    }
  });

  // Create player instances
  party.players.forEach(name => {
    combatants.push({
      id: uuid(),
      name: name,
      type: 'player',
      init: 0
    });
  });

  const newCombat = {
    id: uuid(),
    name: enc.name + ' - ' + party.name,
    encounterId: enc.id,
    partyId: party.id,
    round: 0,
    turnIndex: 0,
    combatants: combatants,
    active: true
  };
  state.combats.push(newCombat);
  activeCombatId = newCombat.id;

  pendingCombatEncounterId = null;
  saveCombat();
  setStatus('Rolling initiative for ' + enc.name + '...', 'success');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Initiative Setup ──
// ═══════════════════════════════════════════════════════════════

function renderInitiativeSetup(el) {
  const combat = getActiveCombat();
  const enc = state.encounters.find(e => e.id === combat.encounterId);

  let html = '<div class="form-section">';
  html += '<div class="form-section-title">Initiative Setup' + (enc ? ': ' + esc(enc.name) : '') + '</div>';
  html += '<p class="text-muted-sm" style="margin-bottom:0.75rem">Enter player initiatives. Monster initiatives are pre-rolled but editable.</p>';

  // Sort for display: monsters first (already have init), then players
  const sorted = [...combat.combatants].sort((a, b) => {
    if (a.type === 'player' && b.type !== 'player') return 1;
    if (a.type !== 'player' && b.type === 'player') return -1;
    return (b.init ?? -Infinity) - (a.init ?? -Infinity);
  });

  sorted.forEach(c => {
    const idx = combat.combatants.indexOf(c);
    const typeLabel = c.type === 'player' ? 'Player' : c.type === 'adhoc' ? 'Other' : 'Monster';
    const typeColor = c.type === 'player' ? 'var(--success)' : c.type === 'adhoc' ? 'var(--warning)' : 'var(--text-dim)';
    html += '<div class="init-setup-row">';
    html += '<span style="font-size:0.65rem;color:' + typeColor + ';text-transform:uppercase;font-weight:600">' + typeLabel + '</span>';
    html += '<span style="font-size:0.85rem;font-weight:600">' + esc(c.name) + '</span>';
    html += '<span style="font-family:var(--mono);font-size:0.7rem;color:var(--text-dim);text-align:right">' + (c.initRollText ? esc(c.initRollText) : '') + '</span>';
    html += '<input type="number" value="' + (c.init !== null && c.init !== undefined ? c.init : '') + '" step="0.01" onchange="setCombatantInit(' + idx + ',this.value)" placeholder="Init">';
    html += '</div>';
  });

  html += '<div style="margin-top:0.75rem;display:flex;gap:0.5rem">';
  html += '<button class="btn-sm" onclick="showAddCombatantModal()">+ Add</button>';
  html += '</div>';

  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="beginCombat()">Begin Combat</button>';
  html += '<button class="btn-danger" onclick="endCombat()">Cancel</button>';
  html += '</div>';
  html += '</div>';

  el.innerHTML = html;
}

function setCombatantInit(idx, value) {
  const c = getCombatant(idx);
  if (!c) return;
  c.init = value === '' ? null : +value;
  saveCombat();
}

function filterCombatMonsterPicker(query) {
  const dropdown = document.getElementById('combatMonsterPickerDropdown');
  if (!dropdown) return;
  const q = query.toLowerCase();
  const matches = state.templates.filter(t => t.name.toLowerCase().includes(q));
  if (matches.length === 0) {
    dropdown.innerHTML = '<div class="search-dropdown-item" style="color:var(--text-dim);cursor:default">No matches</div>';
  } else {
    dropdown.innerHTML = matches.map(t =>
      '<div class="search-dropdown-item" onmousedown="selectCombatMonster(\'' + t.id + '\')">'
      + esc(t.name) + '<span class="cr-tag">CR ' + esc(t.cr || '?') + '</span></div>'
    ).join('');
  }
  dropdown.classList.add('open');
}

function selectCombatMonster(templateId) {
  const input = document.getElementById('combatMonsterPicker');
  const dropdown = document.getElementById('combatMonsterPickerDropdown');
  const t = state.templates.find(t => t.id === templateId);
  if (!input || !t) return;
  input.value = t.name;
  input.dataset.templateId = templateId;
  if (dropdown) dropdown.classList.remove('open');
}

function showAddCombatantModal() {
  const combat = getActiveCombat();
  const isActive = combat.round >= 1;
  const defaultInit = isActive ? '20' : '';

  const bodyHtml =
    '<div class="modal-toggle-group">' +
    '<button id="addModeAdhoc" class="active" onclick="switchAddMode(\'adhoc\')">Ad-hoc</button>' +
    '<button id="addModePlayer" onclick="switchAddMode(\'player\')">Player</button>' +
    '<button id="addModeTemplate" onclick="switchAddMode(\'template\')">Monster</button>' +
    '</div>' +
    '<div id="addCombatantBody">' +
    '<div class="flex-col">' +
    '<label style="font-size:0.75rem;color:var(--text-muted)">Name</label>' +
    '<input type="text" id="addCombatantName" placeholder="Lair Actions, Doors, Siege Engines..." onclick="event.stopPropagation()" style="padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem">' +
    '<div style="display:flex;gap:0.75rem;align-items:flex-end">' +
    '<div><label style="font-size:0.75rem;color:var(--text-muted)">Initiative</label>' +
    '<input type="number" id="addCombatantInit" value="' + defaultInit + '" step="0.01" placeholder="Init" onclick="event.stopPropagation()" style="width:80px;padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem;font-family:var(--mono);display:block"></div>' +
    '<div><label style="font-size:0.75rem;color:var(--text-muted)">HP <span style="color:var(--text-dim)">(optional)</span></label>' +
    '<input type="number" id="addCombatantHP" min="1" placeholder="-" onclick="event.stopPropagation()" style="width:80px;padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem;font-family:var(--mono);display:block"></div>' +
    '<div><label style="font-size:0.75rem;color:var(--text-muted)">AC <span style="color:var(--text-dim)">(optional)</span></label>' +
    '<input type="number" id="addCombatantAdhocAC" placeholder="-" onclick="event.stopPropagation()" style="width:60px;padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem;font-family:var(--mono);display:block"></div>' +
    '</div>' +
    '</div>' +
    '</div>' +
    '<div class="flex-row-end" style="margin-top:1rem">' +
    '<button class="btn-sm" onclick="document.getElementById(\'addCombatantModal\').remove()">Cancel</button>' +
    '<button class="btn-sm btn-action" onclick="doAddCombatant()">Add</button>' +
    '</div>';
  createModal('addCombatantModal', 'Add Combatant', bodyHtml, { wide: true, focusId: 'addCombatantName' });
}

function switchAddMode(mode) {
  const btns = ['addModeAdhoc', 'addModePlayer', 'addModeTemplate'];
  btns.forEach(function(id) {
    const el = document.getElementById(id);
    if (el) el.className = (id === 'addMode' + mode.charAt(0).toUpperCase() + mode.slice(1)) ? 'active' : '';
  });
  const body = document.getElementById('addCombatantBody');
  if (!body) return;
  const combat = getActiveCombat();
  const isActive = combat.round >= 1;
  const defaultInit = isActive ? '20' : '';
  const inputStyle = 'padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem';
  const monoStyle = inputStyle + ';font-family:var(--mono)';

  if (mode === 'adhoc') {
    body.innerHTML =
      '<div class="flex-col">' +
      '<label style="font-size:0.75rem;color:var(--text-muted)">Name</label>' +
      '<input type="text" id="addCombatantName" placeholder="Lair Actions, Doors, Siege Engines..." onclick="event.stopPropagation()" style="' + inputStyle + '">' +
      '<div style="display:flex;gap:0.75rem;align-items:flex-end">' +
      '<div><label style="font-size:0.75rem;color:var(--text-muted)">Initiative</label>' +
      '<input type="number" id="addCombatantInit" value="' + defaultInit + '" step="0.01" placeholder="Init" onclick="event.stopPropagation()" style="width:80px;' + monoStyle + ';display:block"></div>' +
      '<div><label style="font-size:0.75rem;color:var(--text-muted)">HP <span style="color:var(--text-dim)">(optional)</span></label>' +
      '<input type="number" id="addCombatantHP" min="1" placeholder="-" onclick="event.stopPropagation()" style="width:80px;' + monoStyle + ';display:block"></div>' +
      '<div><label style="font-size:0.75rem;color:var(--text-muted)">AC <span style="color:var(--text-dim)">(optional)</span></label>' +
      '<input type="number" id="addCombatantAdhocAC" placeholder="-" onclick="event.stopPropagation()" style="width:60px;' + monoStyle + ';display:block"></div>' +
      '</div>' +
      '</div>';
    setTimeout(function() { const el = document.getElementById('addCombatantName'); if (el) el.focus(); }, 50);
  } else if (mode === 'player') {
    body.innerHTML =
      '<div class="flex-col">' +
      '<label style="font-size:0.75rem;color:var(--text-muted)">Player Name</label>' +
      '<input type="text" id="addCombatantName" placeholder="Player name..." onclick="event.stopPropagation()" style="' + inputStyle + '">' +
      '<div style="display:flex;gap:0.75rem;align-items:flex-end">' +
      '<div><label style="font-size:0.75rem;color:var(--text-muted)">Initiative</label>' +
      '<input type="number" id="addCombatantInit" step="0.01" placeholder="Init" onclick="event.stopPropagation()" style="width:80px;' + monoStyle + ';display:block"></div>' +
      '<div><label style="font-size:0.75rem;color:var(--text-muted)">AC</label>' +
      '<input type="number" id="addCombatantAC" placeholder="AC" onclick="event.stopPropagation()" style="width:60px;' + monoStyle + ';display:block"></div>' +
      '</div>' +
      '<label style="font-size:0.75rem;color:var(--text-muted)">Notes</label>' +
      '<input type="text" id="addCombatantNotes" placeholder="Optional notes..." onclick="event.stopPropagation()" style="' + inputStyle + '">' +
      '</div>';
    setTimeout(function() { const el = document.getElementById('addCombatantName'); if (el) el.focus(); }, 50);
  } else {
    body.innerHTML =
      '<div class="flex-col">' +
      '<label style="font-size:0.75rem;color:var(--text-muted)">Monster</label>' +
      '<div class="search-select">' +
      '<input type="text" id="combatMonsterPicker" placeholder="Search monsters..." autocomplete="off"' +
      ' oninput="filterCombatMonsterPicker(this.value)" onfocus="filterCombatMonsterPicker(this.value)"' +
      ' onclick="event.stopPropagation()"' +
      ' style="width:100%;' + inputStyle + ';box-sizing:border-box">' +
      '<div id="combatMonsterPickerDropdown" class="search-dropdown"></div>' +
      '</div>' +
      '<div style="display:flex;gap:0.75rem;align-items:flex-end">' +
      '<div><label style="font-size:0.75rem;color:var(--text-muted)">Quantity</label>' +
      '<input type="number" id="addCombatantQty" value="1" min="1" max="20" onclick="event.stopPropagation()" style="width:60px;' + monoStyle + ';display:block"></div>' +
      '<div><label style="font-size:0.75rem;color:var(--text-muted)">Init Override <span style="color:var(--text-dim)">(blank = roll)</span></label>' +
      '<input type="number" id="addCombatantInit" step="0.01" placeholder="Auto" onclick="event.stopPropagation()" style="width:80px;' + monoStyle + ';display:block"></div>' +
      '</div>' +
      '</div>';
    setTimeout(function() { const el = document.getElementById('combatMonsterPicker'); if (el) el.focus(); }, 50);
  }
}

function doAddCombatant() {
  const combat = getActiveCombat();
  const activeMode = document.getElementById('addModeTemplate') && document.getElementById('addModeTemplate').className === 'active' ? 'template'
    : document.getElementById('addModePlayer') && document.getElementById('addModePlayer').className === 'active' ? 'player'
    : 'adhoc';

  if (activeMode === 'template') {
    // Template monster path
    const pickerEl = document.getElementById('combatMonsterPicker');
    const templateId = pickerEl && pickerEl.dataset.templateId;
    if (!templateId) { setStatus('Select a monster template.', 'error'); return; }
    const template = state.templates.find(t => t.id === templateId);
    if (!template) { setStatus('Template not found.', 'error'); return; }

    const qtyEl = document.getElementById('addCombatantQty');
    const qty = Math.max(1, Math.min(20, parseInt(qtyEl && qtyEl.value) || 1));
    const initEl = document.getElementById('addCombatantInit');
    const initOverride = initEl && initEl.value !== '' ? +initEl.value : null;

    const existingCount = getExistingMonsterCount(combat, templateId);
    const totalAfter = existingCount + qty;

    // Retroactively number existing bare-name instances if adding more of the same
    if (existingCount === 1 && totalAfter > 1) {
      const existing = combat.combatants.find(c => c.templateId === templateId);
      if (existing && existing.name === template.name) {
        existing.name = template.name + ' 1';
      }
    }

    const startNum = existingCount > 0 ? existingCount + 1 : (qty > 1 ? 1 : 0);
    for (let i = 0; i < qty; i++) {
      const num = startNum > 0 ? startNum + i : 0;
      const name = num > 0 ? template.name + ' ' + num : template.name;
      const c = createMonsterCombatant(template, name);
      if (initOverride !== null) c.init = initOverride;
      combat.combatants.push(c);
    }
    setStatus('Added ' + qty + 'x ' + template.name, 'success');
  } else if (activeMode === 'player') {
    // Player path
    const nameEl = document.getElementById('addCombatantName');
    const name = nameEl && nameEl.value.trim();
    if (!name) { setStatus('Enter a player name.', 'error'); return; }
    const initEl = document.getElementById('addCombatantInit');
    const init = initEl && initEl.value !== '' ? +initEl.value : null;
    const acEl = document.getElementById('addCombatantAC');
    const ac = acEl && acEl.value !== '' ? +acEl.value : null;
    const notesEl = document.getElementById('addCombatantNotes');
    const notes = notesEl && notesEl.value.trim() || '';
    combat.combatants.push({
      id: uuid(),
      name: name,
      type: 'player',
      init: init,
      ac: ac,
      notes: notes
    });
    setStatus('Added player: ' + name, 'success');
  } else {
    // Ad-hoc path
    const nameEl = document.getElementById('addCombatantName');
    const name = nameEl && nameEl.value.trim();
    if (!name) { setStatus('Enter a combatant name.', 'error'); return; }
    const initEl = document.getElementById('addCombatantInit');
    const init = initEl && initEl.value !== '' ? +initEl.value : 20.0;
    const hpEl = document.getElementById('addCombatantHP');
    const hp = hpEl && hpEl.value !== '' ? Math.max(1, parseInt(hpEl.value) || 0) : null;
    const acEl = document.getElementById('addCombatantAdhocAC');
    const acVal = acEl && acEl.value !== '' ? parseInt(acEl.value) || 0 : null;
    const entry = {
      id: uuid(),
      name: name,
      type: 'adhoc',
      init: init,
      notes: ''
    };
    if (hp !== null) { entry.hpMax = hp; entry.currentHp = hp; }
    if (acVal !== null) { entry.ac = acVal; }
    combat.combatants.push(entry);
    setStatus('Added: ' + name, 'success');
  }

  // Sort and preserve turn if active combat
  if (combat.round >= 1) {
    const currentId = combat.combatants[combat.turnIndex].id;
    combat.combatants.sort((a, b) => (b.init ?? -Infinity) - (a.init ?? -Infinity));
    combat.turnIndex = combat.combatants.findIndex(c => c.id === currentId);
    if (combat.turnIndex < 0) combat.turnIndex = 0;
  }
  saveCombat();
  const modal = document.getElementById('addCombatantModal');
  if (modal) modal.remove();
  render();
}

function beginCombat() {
  const combat = getActiveCombat();
  const missing = combat.combatants.filter(c => c.type === 'player' && (c.init === null || c.init === undefined));
  if (missing.length > 0) {
    setStatus('Enter initiative for: ' + missing.map(c => c.name).join(', '), 'error');
    return;
  }
  combat.combatants.sort((a, b) => (b.init ?? -Infinity) - (a.init ?? -Infinity));
  combat.round = 1;
  combat.turnIndex = 0;
  combat.combatants.forEach(c => { c.reactionUsed = false; });
  // Auto-expand the first combatant
  const first = combat.combatants[0];
  if (first && !first._expanded) {
    first._expanded = true;
    autoExpandedId = first.id;
  }
  saveCombat();
  setStatus('Round 1 - ' + first.name + '\'s turn', 'success');
  render();

  // Lair action notification — deduplicated by templateId
  const lairTemplates = {};
  combat.combatants.forEach(function(c) {
    if (c.type !== 'monster' || !c.templateId || lairTemplates[c.templateId]) return;
    const t = getTemplate(c);
    if (t && t.lairActions && t.lairActions.length > 0) {
      lairTemplates[c.templateId] = { name: t.name, actions: t.lairActions };
    }
  });
  const lairEntries = Object.values(lairTemplates);
  if (lairEntries.length > 0) {
    let body = '';
    lairEntries.forEach(function(entry) {
      body += '<div class="detail-section-title" style="margin-top:0.5rem;color:var(--accent)">' + esc(entry.name) + '</div>';
      entry.actions.forEach(function(la) {
        body += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
        body += '<div style="font-size:0.75rem"><strong>' + esc(la.name) + '</strong></div>';
        if (la.desc) body += '<div class="text-dim-sm" style="margin-top:0.15rem">' + esc(la.desc) + '</div>';
        body += '</div>';
      });
    });
    body += '<div style="margin-top:0.75rem;font-size:0.72rem;color:var(--text-dim)">Use + Add to create a Lair combatant in the initiative order.</div>';
    body += '<div style="margin-top:0.75rem;text-align:right"><button class="btn-action" onclick="this.closest(\'.modal-overlay\').remove()">Got it</button></div>';
    createModal('lairNotifyModal', 'Lair Actions Available', body, { clickOutsideClose: true, escapeClose: true });
  }
}

// ═══════════════════════════════════════════════════════════════
// ── Edit Mode (Combat Overrides) ──
// ═══════════════════════════════════════════════════════════════

function exitEditMode() {
  editState.mode = false;
  editState.selected = [];
  editState.lockedTemplateId = null;
  editState.formData = null;
  editState.visible = false;
  editState.rawTemplate = null;
  editState.formSnapshot = null;
  editState.conflicts.clear();
  render();
}

function toggleEditMode() {
  if (editState.mode) {
    exitEditMode();
  } else {
    editState.mode = true;
    editState.selected = [];
    editState.lockedTemplateId = null;
    editState.formData = null;
    editState.visible = false;
    editState.rawTemplate = null;
    editState.formSnapshot = null;
    editState.conflicts.clear();
    render();
  }
}

function toggleEditSelect(combatantId, templateId) {
  const idx = editState.selected.indexOf(combatantId);
  if (idx >= 0) {
    editState.selected.splice(idx, 1);
    if (editState.selected.length === 0) editState.lockedTemplateId = null;
  } else {
    if (editState.lockedTemplateId === null) editState.lockedTemplateId = templateId;
    editState.selected.push(combatantId);
  }
  render();
}

function openEditForm() {
  const combat = getActiveCombat();
  if (!combat || editState.selected.length === 0) return;
  const selected = combat.combatants.filter(function(c) { return editState.selected.indexOf(c.id) >= 0; });
  if (selected.length === 0) return;

  // Get raw template for diffing
  editState.rawTemplate = getRawTemplate(selected[0]);
  if (!editState.rawTemplate) return;

  // Build editState.formData from the first selected combatant's effective values
  const firstEffective = getTemplate(selected[0]);
  editState.formData = deepClone(firstEffective);

  // Detect conflicts: fields where selected combatants have different effective values
  editState.conflicts.clear();
  if (selected.length > 1) {
    const paths = flattenPaths(firstEffective, '');
    paths.forEach(function(path) {
      const baseVal = getNestedValue(firstEffective, path);
      for (let i = 1; i < selected.length; i++) {
        const otherEffective = getTemplate(selected[i]);
        const otherVal = getNestedValue(otherEffective, path);
        if (JSON.stringify(baseVal) !== JSON.stringify(otherVal)) {
          editState.conflicts.add(path);
          break;
        }
      }
    });
  }

  editState.formSnapshot = JSON.stringify(editState.formData);
  editState.visible = true;
  render();
}

function isEditFormDirty() {
  return JSON.stringify(editState.formData) !== editState.formSnapshot;
}

function getNestedValue(obj, path) {
  const parts = path.split('.');
  let cur = obj;
  for (let i = 0; i < parts.length; i++) {
    if (cur === null || cur === undefined) return undefined;
    const key = parts[i];
    if (Array.isArray(cur)) {
      cur = cur[parseInt(key)];
    } else {
      cur = cur[key];
    }
  }
  return cur;
}

function flattenPaths(obj, prefix) {
  let result = [];
  if (obj === null || obj === undefined || typeof obj !== 'object') {
    if (prefix) result.push(prefix);
    return result;
  }
  if (Array.isArray(obj)) {
    obj.forEach(function(item, i) {
      const p = prefix ? prefix + '.' + i : '' + i;
      result = result.concat(flattenPaths(item, p));
    });
  } else {
    Object.keys(obj).forEach(function(key) {
      const p = prefix ? prefix + '.' + key : key;
      result = result.concat(flattenPaths(obj[key], p));
    });
  }
  return result;
}

function isEditFieldModified(fieldPath) {
  const raw = getNestedValue(editState.rawTemplate, fieldPath);
  const cur = getNestedValue(editState.formData, fieldPath);
  return JSON.stringify(raw) !== JSON.stringify(cur);
}

function revertEditField(fieldPath) {
  const parts = fieldPath.split('.');
  const rawVal = getNestedValue(editState.rawTemplate, fieldPath);
  let obj = editState.formData;
  for (let i = 0; i < parts.length - 1; i++) {
    const key = parts[i];
    if (Array.isArray(obj)) obj = obj[parseInt(key)];
    else obj = obj[key];
  }
  const lastKey = parts[parts.length - 1];
  if (Array.isArray(obj)) obj[parseInt(lastKey)] = deepClone(rawVal);
  else obj[lastKey] = deepClone(rawVal);
  renderEditOverrideForm();
}

// Per-item revert for saves (matched by ability name)
function isSaveItemModified(idx) {
  const save = editState.formData.savingThrows[idx];
  if (!save) return false;
  const ts = editState.rawTemplate.savingThrows.find(function(s) { return s.ability === save.ability; });
  if (!ts) return true; // added item - not in template
  return ts.bonus !== save.bonus;
}
function revertSaveItem(idx) {
  const save = editState.formData.savingThrows[idx];
  if (!save) return;
  const ts = editState.rawTemplate.savingThrows.find(function(s) { return s.ability === save.ability; });
  if (ts) editState.formData.savingThrows[idx] = deepClone(ts);
  else editState.formData.savingThrows.splice(idx, 1); // added item - remove it
  renderEditOverrideForm();
}
function restoreDeletedSave(ability) {
  const ts = editState.rawTemplate.savingThrows.find(function(s) { return s.ability === ability; });
  if (ts) editState.formData.savingThrows.push(deepClone(ts));
  renderEditOverrideForm();
}

// Per-item revert for skills (matched by skill name)
function isSkillItemModified(idx) {
  const skill = editState.formData.skills[idx];
  if (!skill) return false;
  const ts = editState.rawTemplate.skills.find(function(s) { return s.name === skill.name; });
  if (!ts) return true; // added item - not in template
  return ts.bonus !== skill.bonus;
}
function revertSkillItem(idx) {
  const skill = editState.formData.skills[idx];
  if (!skill) return;
  const ts = editState.rawTemplate.skills.find(function(s) { return s.name === skill.name; });
  if (ts) editState.formData.skills[idx] = deepClone(ts);
  else editState.formData.skills.splice(idx, 1); // added item - remove it
  renderEditOverrideForm();
}
function restoreDeletedSkill(name) {
  const ts = editState.rawTemplate.skills.find(function(s) { return s.name === name; });
  if (ts) editState.formData.skills.push(deepClone(ts));
  renderEditOverrideForm();
}

function editFieldAttr(fieldPath) {
  let cls = '';
  if (editState.conflicts.has(fieldPath)) cls = ' class="edit-field-conflict" disabled placeholder="Varies" title="Varies across selected combatants"';
  else if (isEditFieldModified(fieldPath)) cls = ' class="edit-field-modified"';
  return cls;
}

function editVal(val, fieldPath) {
  return editState.conflicts.has(fieldPath) ? '' : val;
}

function editRevertBtn(fieldPath) {
  if (editState.conflicts.has(fieldPath)) return '';
  if (!isEditFieldModified(fieldPath)) return '';
  return ' <button class="btn-revert" onclick="revertEditField(\'' + fieldPath + '\')" title="Revert to template">↩</button>';
}

// Override highlight wrapper: wraps content in highlight span if field is overridden
function ovh(c, fieldPath, content) {
  if (isFieldOverridden(c, fieldPath)) return '<span class="override-highlight">' + content + '</span>';
  return content;
}

function applyEditOverrides() {
  const combat = getActiveCombat();
  if (!combat) { exitEditMode(); return; }
  const overrides = sparseOverrides(editState.rawTemplate, editState.formData);
  let count = 0;
  editState.selected.forEach(function(cId) {
    const c = combat.combatants.find(function(cb) { return cb.id === cId; });
    if (!c) return;
    if (editState.conflicts.size > 0 && c.overrides) {
      // Preserve existing overrides for conflicting fields
      const preserved = {};
      editState.conflicts.forEach(function(path) {
        const val = getNestedValue(c.overrides, path);
        if (val !== undefined) {
          setNestedValue(preserved, path, deepClone(val));
        }
      });
      c.overrides = Object.keys(overrides).length > 0 ? deepClone(overrides) : {};
      // Merge preserved conflict values back
      if (Object.keys(preserved).length > 0) {
        c.overrides = deepMerge(c.overrides, preserved);
      }
    } else {
      c.overrides = Object.keys(overrides).length > 0 ? deepClone(overrides) : {};
    }
    count++;
  });
  saveCombat();
  editState.formSnapshot = JSON.stringify(editState.formData);
  setStatus('Applied overrides to ' + count + ' combatant' + (count !== 1 ? 's' : ''), 'success');
}

function closeEditOverrides() {
  if (isEditFormDirty()) {
    if (!confirm('You have unsaved changes. Close without saving?')) return;
  }
  exitEditMode();
}

function setNestedValue(obj, path, val) {
  const parts = path.split('.');
  let cur = obj;
  for (let i = 0; i < parts.length - 1; i++) {
    const key = parts[i];
    if (cur[key] === undefined) {
      // If the next key is numeric, create an array instead of an object
      const nextKey = parts[i + 1];
      cur[key] = (!isNaN(parseInt(nextKey)) && String(parseInt(nextKey)) === nextKey) ? [] : {};
    }
    cur = cur[key];
  }
  cur[parts[parts.length - 1]] = val;
}

function cancelEditOverrides() {
  if (isEditFormDirty()) {
    if (!confirm('Discard all changes?')) return;
  }
  setStatus('', '');
  exitEditMode();
}

function editSingleCombatant(idx) {
  const combat = getActiveCombat();
  if (!combat) return;
  const c = combat.combatants[idx];
  if (!c || c.type !== 'monster') return;
  editState.mode = true;
  editState.selected = [c.id];
  editState.lockedTemplateId = c.templateId;
  openEditForm();
}

function renderEditOverrideForm() {
  const el = document.getElementById('editOverrideContainer');
  if (!el || !editState.formData || !editState.rawTemplate) return;
  const d = editState.formData;
  let html = '';

  html += '<div class="form-section"><div class="form-section-title">Editing ' + editState.selected.length + ' combatant' + (editState.selected.length !== 1 ? 's' : '') + ' - ' + esc(editState.rawTemplate.name) + '</div></div>';

  // ── Basic Info ──
  html += '<div class="form-section"><div class="form-section-title">Basic Info</div>';
  html += '<div class="form-grid cols-4">';
  html += editField('Name', 'text', d.name, 'editState.formData.name=this.value', 'name');
  html += editField('Size', 'text', d.size, 'editState.formData.size=this.value', 'size');
  html += editField('Type', 'text', d.type, 'editState.formData.type=this.value', 'type');
  html += editField('Alignment', 'text', d.alignment, 'editState.formData.alignment=this.value', 'alignment');
  html += '</div>';
  html += '<div class="form-grid cols-4" style="margin-top:0.5rem">';
  html += editField('AC', 'number', d.ac, 'editState.formData.ac=+this.value', 'ac');
  html += editField('AC Note', 'text', d.acNote, 'editState.formData.acNote=this.value', 'acNote');
  html += editField('HP Max', 'number', d.hpMax, 'editState.formData.hpMax=+this.value', 'hpMax');
  html += editField('HP Formula', 'text', d.hpFormula, 'editState.formData.hpFormula=this.value', 'hpFormula');
  html += '</div>';
  html += '<div class="form-grid cols-4" style="margin-top:0.5rem">';
  html += editField('Speed', 'text', d.speed, 'editState.formData.speed=this.value', 'speed');
  html += editField('CR', 'text', d.cr, 'editState.formData.cr=this.value', 'cr');
  html += editField('Init Bonus', 'number', d.initBonus, 'editState.formData.initBonus=+this.value', 'initBonus');
  html += '<div class="form-field"><div class="flex-row-tight"><label class="checkbox-label"><input type="checkbox" ' + (d.initAdvantage ? 'checked' : '') + ' onchange="editState.formData.initAdvantage=this.checked"' + editFieldAttr('initAdvantage') + '> Init Advantage</label>' + editRevertBtn('initAdvantage') + '</div></div>';
  html += '</div>';
  html += '<div class="form-grid cols-2" style="margin-top:0.5rem">';
  html += editField('Source', 'text', d.source || '', 'editState.formData.source=this.value', 'source');
  html += editField('Gear', 'text', d.gear || '', 'editState.formData.gear=this.value', 'gear');
  html += '</div></div>';

  // ── Ability Scores ──
  html += '<div class="form-section"><div class="form-section-title">Ability Scores</div>';
  html += '<div class="form-grid cols-6">';
  ABILITIES.forEach(function(ab) {
    const score = d.abilities[ab];
    const fp = 'abilities.' + ab;
    html += '<div class="form-field"><label>' + ab.toUpperCase() + ' (' + modStr(score) + ')</label>';
    html += '<div class="flex-row-tight">';
    html += '<input type="number" value="' + editVal(score, fp) + '" onchange="editState.formData.abilities.' + ab + '=+this.value" style="flex:1"' + editFieldAttr(fp) + '>';
    html += editRevertBtn(fp);
    html += '</div></div>';
  });
  html += '</div></div>';

  // ── Saving Throws (add/remove allowed, per-item revert) ──
  html += '<div class="form-section"><div class="form-section-title">Saving Throws</div>';
  d.savingThrows.forEach(function(st, i) {
    const itemMod = isSaveItemModified(i);
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    html += '<div class="dyn-row">';
    html += '<select onchange="editState.formData.savingThrows[' + i + '].ability=this.value;renderEditOverrideForm()" style="width:120px">';
    ABILITIES.forEach(function(ab) {
      html += '<option value="' + ab + '"' + (st.ability === ab ? ' selected' : '') + '>' + ABILITY_NAMES[ab] + '</option>';
    });
    html += '</select>';
    html += '<input type="number" value="' + st.bonus + '" onchange="editState.formData.savingThrows[' + i + '].bonus=+this.value;renderEditOverrideForm()" style="width:60px" placeholder="+0"' + (itemMod ? ' class="edit-field-modified"' : '') + '>';
    if (itemMod) html += '<button class="btn-revert" onclick="revertSaveItem(' + i + ')" title="Revert to template">↩</button>';
    html += '<button class="btn-remove" onclick="editState.formData.savingThrows.splice(' + i + ',1);renderEditOverrideForm()">×</button>';
    html += '</div>';
    html += '</div>';
  });
  // Show deleted saves (in template but not in editState.formData) with restore buttons
  const deletedSaves = editState.rawTemplate.savingThrows.filter(function(ts) {
    return !d.savingThrows.some(function(s) { return s.ability === ts.ability; });
  });
  deletedSaves.forEach(function(ds) {
    html += '<div class="dyn-row"><span style="text-decoration:line-through;opacity:0.5">' + ABILITY_NAMES[ds.ability] + ' +' + ds.bonus + '</span>';
    html += '<button class="btn-revert" onclick="restoreDeletedSave(\'' + ds.ability + '\')" title="Restore from template">↩</button></div>';
  });
  html += '<button class="btn-add-row" onclick="editState.formData.savingThrows.push({ability:\'str\',bonus:0});renderEditOverrideForm()">+ Add Save</button>';
  html += '</div>';

  // ── Skills (add/remove allowed, per-item revert) ──
  html += '<div class="form-section"><div class="form-section-title">Skills</div>';
  d.skills.forEach(function(sk, i) {
    const itemMod = isSkillItemModified(i);
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    html += '<div class="dyn-row">';
    html += '<select onchange="editState.formData.skills[' + i + '].name=this.value;renderEditOverrideForm()" style="width:150px">';
    SKILLS.forEach(function(s) {
      html += '<option value="' + s + '"' + (sk.name === s ? ' selected' : '') + '>' + s + '</option>';
    });
    html += '</select>';
    html += '<input type="number" value="' + sk.bonus + '" onchange="editState.formData.skills[' + i + '].bonus=+this.value;renderEditOverrideForm()" style="width:60px" placeholder="+0"' + (itemMod ? ' class="edit-field-modified"' : '') + '>';
    if (itemMod) html += '<button class="btn-revert" onclick="revertSkillItem(' + i + ')" title="Revert to template">↩</button>';
    html += '<button class="btn-remove" onclick="editState.formData.skills.splice(' + i + ',1);renderEditOverrideForm()">×</button>';
    html += '</div>';
    html += '</div>';
  });
  // Show deleted skills (in template but not in editState.formData) with restore buttons
  const deletedSkills = editState.rawTemplate.skills.filter(function(ts) {
    return !d.skills.some(function(s) { return s.name === ts.name; });
  });
  deletedSkills.forEach(function(ds) {
    html += '<div class="dyn-row"><span style="text-decoration:line-through;opacity:0.5">' + esc(ds.name) + ' +' + ds.bonus + '</span>';
    html += '<button class="btn-revert" onclick="restoreDeletedSkill(\'' + esc(ds.name).replace(/'/g, "\\'") + '\')" title="Restore from template">↩</button></div>';
  });
  html += '<button class="btn-add-row" onclick="editState.formData.skills.push({name:\'Perception\',bonus:0});renderEditOverrideForm()">+ Add Skill</button>';
  html += '</div>';

  // ── Defenses ──
  html += '<div class="form-section"><div class="form-section-title">Defenses & Senses</div>';
  html += '<div class="form-grid cols-2">';
  html += editField('Damage Resistances', 'text', d.damageResistances, 'editState.formData.damageResistances=this.value', 'damageResistances');
  html += editField('Damage Immunities', 'text', d.damageImmunities, 'editState.formData.damageImmunities=this.value', 'damageImmunities');
  html += editField('Damage Vulnerabilities', 'text', d.damageVulnerabilities, 'editState.formData.damageVulnerabilities=this.value', 'damageVulnerabilities');
  html += editField('Condition Immunities', 'text', d.conditionImmunities, 'editState.formData.conditionImmunities=this.value', 'conditionImmunities');
  html += editField('Senses', 'text', d.senses, 'editState.formData.senses=this.value', 'senses');
  html += editField('Languages', 'text', d.languages, 'editState.formData.languages=this.value', 'languages');
  html += '</div>';
  html += '<div class="form-grid cols-2" style="margin-top:0.5rem">';
  html += editField('Passive Perception', 'number', d.passivePerception != null ? d.passivePerception : '', 'editState.formData.passivePerception=this.value===\'\'?null:+this.value', 'passivePerception');
  html += '<div class="form-field"></div>';
  html += '</div></div>';

  // ── Attacks (no add/remove - index-referenced) ──
  html += '<div class="form-section"><div class="form-section-title">Attacks</div>';
  html += '<div class="form-grid cols-2">';
  html += editField('Multiattack', 'text', d.multiattack, 'editState.formData.multiattack=this.value', 'multiattack');
  html += editField('Crits On', 'number', d.critRange || 20, 'editState.formData.critRange=+this.value||20', 'critRange');
  html += '</div>';
  html += '<div style="margin-top:0.5rem">';
  d.attacks.forEach(function(a, i) {
    const afp = 'attacks.' + i;
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
    html += '<input type="text" value="' + esc(editVal(a.name, afp + '.name')) + '" onchange="editState.formData.attacks[' + i + '].name=this.value" placeholder="Name" style="flex:2"' + editFieldAttr(afp + '.name') + '>';
    html += editRevertBtn(afp + '.name');
    html += '<input type="number" value="' + editVal(a.bonus, afp + '.bonus') + '" onchange="editState.formData.attacks[' + i + '].bonus=+this.value" placeholder="+4" style="width:55px"' + editFieldAttr(afp + '.bonus') + '>';
    html += editRevertBtn(afp + '.bonus');
    html += '<input type="text" value="' + esc(editVal(a.note || '', afp + '.note')) + '" onchange="editState.formData.attacks[' + i + '].note=this.value" placeholder="note" style="flex:1"' + editFieldAttr(afp + '.note') + '>';
    html += editRevertBtn(afp + '.note');
    html += '</div>';
    // Damage rows (no add/remove)
    if (a.damages && a.damages.length > 0) {
      html += '<div style="padding-left:0.75rem;border-left:2px solid var(--border)">';
      a.damages.forEach(function(dm, j) {
        const dfp = afp + '.damages.' + j;
        html += '<div class="dyn-row">';
        html += '<input type="text" value="' + esc(editVal(dm.dice, dfp + '.dice')) + '" onchange="editState.formData.attacks[' + i + '].damages[' + j + '].dice=this.value" placeholder="1d8+2" style="width:80px"' + editFieldAttr(dfp + '.dice') + '>';
        html += editRevertBtn(dfp + '.dice');
        html += '<input type="text" value="' + esc(editVal(dm.type, dfp + '.type')) + '" onchange="editState.formData.attacks[' + i + '].damages[' + j + '].type=this.value" placeholder="slashing" style="width:80px"' + editFieldAttr(dfp + '.type') + '>';
        html += editRevertBtn(dfp + '.type');
        html += '<input type="text" value="' + esc(editVal(dm.note || '', dfp + '.note')) + '" onchange="editState.formData.attacks[' + i + '].damages[' + j + '].note=this.value" placeholder="note" style="flex:1"' + editFieldAttr(dfp + '.note') + '>';
        html += editRevertBtn(dfp + '.note');
        html += '</div>';
      });
      html += '</div>';
    }
    html += '<div class="dyn-row" style="margin-top:0.5rem">';
    html += '<textarea onchange="editState.formData.attacks[' + i + '].desc=this.value" placeholder="Special effects, conditions..." style="width:100%"' + editFieldAttr(afp + '.desc') + '>' + esc(editVal(a.desc || '', afp + '.desc')) + '</textarea>';
    html += editRevertBtn(afp + '.desc');
    html += '</div>';
    html += '</div>';
  });
  html += '</div></div>';

  // ── Features (no add/remove - index-referenced) ──
  html += '<div class="form-section"><div class="form-section-title">Features & Abilities</div>';
  d.features.forEach(function(f, i) {
    const ffp = 'features.' + i;
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
    html += '<input type="text" value="' + esc(editVal(f.name, ffp + '.name')) + '" onchange="editState.formData.features[' + i + '].name=this.value" placeholder="Feature name" style="flex:2"' + editFieldAttr(ffp + '.name') + '>';
    html += editRevertBtn(ffp + '.name');
    html += '<input type="text" value="' + esc(editVal(f.recharge || '', ffp + '.recharge')) + '" onchange="editState.formData.features[' + i + '].recharge=this.value||null" placeholder="5-6" style="width:100px"' + editFieldAttr(ffp + '.recharge') + '>';
    html += editRevertBtn(ffp + '.recharge');
    html += '<input type="number" value="' + editVal(f.usesMax || '', ffp + '.usesMax') + '" onchange="editState.formData.features[' + i + '].usesMax=+this.value||null" placeholder="#" style="width:55px"' + editFieldAttr(ffp + '.usesMax') + '>';
    html += editRevertBtn(ffp + '.usesMax');
    html += '</div>';
    html += '<div class="dyn-row"><textarea onchange="editState.formData.features[' + i + '].desc=this.value" placeholder="Description..." style="width:100%"' + editFieldAttr(ffp + '.desc') + '>' + esc(editVal(f.desc, ffp + '.desc')) + '</textarea>';
    html += editRevertBtn(ffp + '.desc');
    html += '</div>';
    html += '</div>';
  });
  html += '</div>';

  // ── Legendary ──
  html += '<div class="form-section"><div class="form-section-title">Legendary</div>';
  html += '<div class="form-grid cols-2">';
  html += editField('Actions/Round', 'number', d.legendaryActionBudget, 'editState.formData.legendaryActionBudget=+this.value', 'legendaryActionBudget');
  html += editField('Resistances', 'number', d.legendaryResistances, 'editState.formData.legendaryResistances=+this.value', 'legendaryResistances');
  html += '</div>';
  html += '<div style="margin-top:0.5rem">';
  d.legendaryActions.forEach(function(la, i) {
    const lfp = 'legendaryActions.' + i;
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    if (i === 0) {
      html += '<div class="dyn-header">';
      html += '<span class="dyn-label" style="flex:2">Name</span>';
      html += '<span class="dyn-label" style="width:55px">Cost</span>';
      html += '</div>';
    }
    html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
    html += '<input type="text" value="' + esc(editVal(la.name, lfp + '.name')) + '" onchange="editState.formData.legendaryActions[' + i + '].name=this.value" placeholder="Action name" style="flex:2"' + editFieldAttr(lfp + '.name') + '>';
    html += editRevertBtn(lfp + '.name');
    html += '<input type="number" value="' + editVal(la.cost, lfp + '.cost') + '" onchange="editState.formData.legendaryActions[' + i + '].cost=+this.value" placeholder="#" style="width:55px"' + editFieldAttr(lfp + '.cost') + '>';
    html += editRevertBtn(lfp + '.cost');
    html += '</div>';
    html += '<div class="dyn-row"><textarea onchange="editState.formData.legendaryActions[' + i + '].desc=this.value" placeholder="Description..." style="width:100%"' + editFieldAttr(lfp + '.desc') + '>' + esc(editVal(la.desc, lfp + '.desc')) + '</textarea>';
    html += editRevertBtn(lfp + '.desc');
    html += '</div>';
    html += '</div>';
  });
  html += '</div>';
  html += '</div>';

  // ── Lair Actions ──
  html += '<div class="form-section"><div class="form-section-title">Lair Actions</div>';
  if (d.lairActions && d.lairActions.length > 0) {
    d.lairActions.forEach(function(la, i) {
      const lfp = 'lairActions.' + i;
      html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
      html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
      html += '<input type="text" value="' + esc(editVal(la.name, lfp + '.name')) + '" onchange="editState.formData.lairActions[' + i + '].name=this.value" placeholder="Lair action name" style="flex:1"' + editFieldAttr(lfp + '.name') + '>';
      html += editRevertBtn(lfp + '.name');
      html += '</div>';
      html += '<div class="dyn-row"><textarea onchange="editState.formData.lairActions[' + i + '].desc=this.value" placeholder="Description..." style="width:100%"' + editFieldAttr(lfp + '.desc') + '>' + esc(editVal(la.desc, lfp + '.desc')) + '</textarea>';
      html += editRevertBtn(lfp + '.desc');
      html += '</div>';
      html += '</div>';
    });
  }
  html += '</div>';

  // ── Tactics ──
  html += '<div class="form-section"><div class="form-section-title">Tactics & Notes</div>';
  html += '<div class="form-field"><div style="display:flex;gap:0.3rem;align-items:flex-start"><textarea rows="3" onchange="editState.formData.tactics=this.value" placeholder="How this monster fights..." style="flex:1"' + editFieldAttr('tactics') + '>' + esc(editVal(d.tactics, 'tactics')) + '</textarea>';
  html += editRevertBtn('tactics');
  html += '</div></div></div>';

  // ── Descriptions ──
  html += '<div class="form-section"><div class="form-section-title">Descriptions</div>';
  html += '<div class="form-field"><label>Player Description</label>';
  html += '<div style="display:flex;gap:0.3rem;align-items:flex-start"><textarea rows="3" onchange="editState.formData.playerDescription=this.value" placeholder="What players see..." style="flex:1"' + editFieldAttr('playerDescription') + '>' + esc(editVal(d.playerDescription || '', 'playerDescription')) + '</textarea>';
  html += editRevertBtn('playerDescription');
  html += '</div></div>';
  html += '<div class="form-field"><label>DM Description</label>';
  html += '<div style="display:flex;gap:0.3rem;align-items:flex-start"><textarea rows="3" onchange="editState.formData.dmDescription=this.value" placeholder="Lore, behavior, SRD reference..." style="flex:1"' + editFieldAttr('dmDescription') + '>' + esc(editVal(d.dmDescription || '', 'dmDescription')) + '</textarea>';
  html += editRevertBtn('dmDescription');
  html += '</div></div></div>';

  // ── Form Actions ──
  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="applyEditOverrides()">Save</button>';
  html += '<button onclick="closeEditOverrides()">Close</button>';
  html += '<button class="btn-danger" onclick="cancelEditOverrides()">Cancel</button>';
  html += '</div>';

  el.innerHTML = html;
}

function editField(label, type, value, onchange, fieldPath) {
  const modified = !editState.conflicts.has(fieldPath) && isEditFieldModified(fieldPath);
  const conflict = editState.conflicts.has(fieldPath);
  let html = '<div class="form-field"><label>' + esc(label) + '</label>';
  html += '<div class="flex-row-tight">';
  if (type === 'number') {
    html += '<input type="number" value="' + (conflict ? '' : (value ?? '')) + '" onchange="' + onchange + '" style="flex:1"';
  } else {
    html += '<input type="text" value="' + (conflict ? '' : esc(value || '')) + '" onchange="' + onchange + '" style="flex:1"';
  }
  if (conflict) html += ' class="edit-field-conflict" disabled placeholder="Varies" title="Varies across selected combatants"';
  else if (modified) html += ' class="edit-field-modified"';
  html += '>';
  html += editRevertBtn(fieldPath);
  html += '</div></div>';
  return html;
}

// ═══════════════════════════════════════════════════════════════
// ── Render Helpers ──
// ═══════════════════════════════════════════════════════════════

function getCombatantHp(c, template) {
  const maxHp = template ? template.hpMax : (c.hpMax || c.currentHp);
  const curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
  const tempHp = c.tempHp || 0;
  return { curHp, maxHp, tempHp };
}

function renderHpBar(curHp, maxHp, tempHp) {
  const pct = maxHp > 0 ? Math.max(0, Math.min(100, Math.round((curHp / maxHp) * 100))) : 0;
  const hpClass = pct > 50 ? 'hp-high' : pct > 25 ? 'hp-mid' : 'hp-low';
  let html = '<div class="hp-bar-container">';
  html += '<div class="hp-bar-fill ' + hpClass + '" style="width:' + pct + '%"></div>';
  html += '<span class="hp-bar-text">' + curHp + (tempHp > 0 ? '+' + tempHp : '') + '/' + maxHp + '</span>';
  html += '</div>';
  return html;
}

function createModal(id, title, bodyHtml, opts) {
  const existing = document.getElementById(id);
  if (existing) existing.remove();
  const modal = document.createElement('div');
  modal.id = id;
  modal.className = 'modal-overlay';
  if (opts && opts.clickOutsideClose) {
    modal.onclick = function(e) { if (e.target === modal) modal.remove(); };
  }
  modal.innerHTML = '<div class="modal-content' + (opts && opts.wide ? ' modal-wide' : '') + '"' +
    (opts && opts.clickOutsideClose ? ' onclick="event.stopPropagation()"' : '') + '>' +
    '<div class="form-section-title" style="margin-bottom:' + (opts && opts.titleMargin || '0.75rem') + '">' + title + '</div>' +
    bodyHtml + '</div>';
  document.body.appendChild(modal);
  if (opts && opts.focusId) {
    setTimeout(function() { const el = document.getElementById(opts.focusId); if (el) el.focus(); }, 50);
  }
  if (opts && opts.escapeClose) {
    const handler = function(e) { if (e.key === 'Escape') { modal.remove(); document.removeEventListener('keydown', handler); } };
    document.addEventListener('keydown', handler);
  }
  return modal;
}

// ═══════════════════════════════════════════════════════════════
// ── Active Combat ──
// ═══════════════════════════════════════════════════════════════

function renderCombatBar(combat) {
  let html = '';
  const editDisabled = editState.mode ? ' disabled style="opacity:0.4"' : '';
  html += '<div class="combat-bar">';
  if (state.combats.length > 1) {
    html += '<button class="btn-sm" onclick="activeCombatId=null;saveCombat();render()" title="Back to combat list"' + editDisabled + '>&laquo; List</button>';
  }
  html += '<span class="round-badge">Round ' + combat.round + '</span>';
  const atStart = combat.round === 1 && combat.turnIndex === 0;
  html += '<button class="btn-sm" onclick="prevTurn()"' + (editState.mode ? editDisabled : (atStart ? ' disabled style="opacity:0.4"' : '')) + '>&laquo; Prev</button>';
  html += '<button class="btn-sm btn-action" onclick="nextTurn()"' + editDisabled + '>Next &raquo;</button>';
  html += '<div class="spacer"></div>';
  if (editState.mode && !editState.visible) {
    html += '<button class="btn-sm btn-action" onclick="openEditForm()"' + (editState.selected.length === 0 ? ' disabled style="opacity:0.4"' : '') + '>Edit Selected</button>';
  }
  html += '<button class="btn-sm' + (editState.mode ? ' btn-warning' : '') + '" onclick="toggleEditMode()">' + (editState.mode ? 'Exit Edit' : 'Edit Mode') + '</button>';
  html += '<button class="btn-sm" onclick="showAddCombatantModal()"' + editDisabled + '>+ Add</button>';
  html += '<button class="btn-sm btn-danger" onclick="endCombat()"' + editDisabled + '>End Combat</button>';
  html += '</div>';
  return html;
}

function renderCombatInfo(combat) {
  let html = '';
  const combatEnc = state.encounters.find(function(e) { return e.id === combat.encounterId; });
  const combatParty = state.parties.find(function(p) { return p.id === combat.partyId; });
  if (combatEnc || combatParty) {
    html += '<div class="combat-info">';
    if (combatParty && combatParty.name) {
      html += '<div class="combat-info-row">';
      html += '<span class="combat-info-label">Party</span>';
      html += '<span class="combat-info-value">' + esc(combatParty.name) + '</span>';
      html += '<button class="btn-sm combat-info-copy" onclick="event.stopPropagation();copyCombatField(this,\'party\')">Copy</button>';
      html += '</div>';
    }
    if (combatEnc) {
      if (combatEnc.name) {
        html += '<div class="combat-info-row">';
        html += '<span class="combat-info-label">Encounter</span>';
        html += '<span class="combat-info-value">' + esc(combatEnc.name) + '</span>';
        html += '<button class="btn-sm combat-info-copy" onclick="event.stopPropagation();copyCombatField(this,\'name\')">Copy</button>';
        html += '</div>';
      }
      if (combatEnc.campaign) {
        html += '<div class="combat-info-row">';
        html += '<span class="combat-info-label">Campaign</span>';
        html += '<span class="combat-info-value">' + esc(combatEnc.campaign) + '</span>';
        html += '<button class="btn-sm combat-info-copy" onclick="event.stopPropagation();copyCombatField(this,\'campaign\')">Copy</button>';
        html += '</div>';
      }
      if (combatEnc.location) {
        html += '<div class="combat-info-row">';
        html += '<span class="combat-info-label">Location</span>';
        html += '<span class="combat-info-value">' + esc(combatEnc.location) + '</span>';
        html += '<button class="btn-sm combat-info-copy" onclick="event.stopPropagation();copyCombatField(this,\'location\')">Copy</button>';
        html += '</div>';
      }
      if (combatEnc.notes) {
        html += '<div class="combat-info-row" style="align-items:flex-start">';
        html += '<span class="combat-info-label">Notes</span>';
        html += '<span class="combat-info-value" style="white-space:pre-wrap">' + esc(combatEnc.notes) + '</span>';
        html += '<button class="btn-sm combat-info-copy" onclick="event.stopPropagation();copyCombatField(this,\'notes\')">Copy</button>';
        html += '</div>';
      }
    }
    html += '</div>';
  }
  return html;
}

function renderCombatantRow(c, idx, template, combat) {
  let html = '';
  const isCurrent = idx === combat.turnIndex;
  const isDead = c.dead || false;

  let rowClasses = 'combatant-row';
  if (isCurrent) rowClasses += ' current-turn';
  if (isDead) rowClasses += ' is-dead';
  // Dim non-selectable rows in edit mode
  const editDimmed = editState.mode && !editState.visible && c.type === 'monster' && editState.lockedTemplateId !== null && c.templateId !== editState.lockedTemplateId;

  html += '<div class="' + rowClasses + '"' + (editDimmed ? ' style="opacity:0.35"' : '') + ' onclick="toggleCombatantDetail(' + idx + ')">';

  // Init (or checkbox in edit mode)
  if (editState.mode && !editState.visible && c.type === 'monster') {
    const canSelect = editState.lockedTemplateId === null || c.templateId === editState.lockedTemplateId;
    const isChecked = editState.selected.indexOf(c.id) >= 0;
    html += '<span class="init-val"><input type="checkbox" class="edit-checkbox"' + (isChecked ? ' checked' : '') + (!canSelect && !isChecked ? ' disabled' : '') + ' onclick="event.stopPropagation();toggleEditSelect(\'' + c.id + '\',\'' + c.templateId + '\')" /></span>';
  } else {
    html += '<span class="init-val">' + (c.init !== null && c.init !== undefined ? Math.floor(c.init) : '-') + '</span>';
  }

  // Name + badges
  const hasOvr = c.type === 'monster' && c.overrides && Object.keys(c.overrides).length > 0;
  html += '<span class="combatant-name type-' + c.type + (hasOvr ? ' has-overrides' : '') + '">' + esc(c.name);
  if (hasOvr) {
    html += '<span class="override-badge" title="Modified">\u2726</span>';
  }
  if (c.type === 'monster' && template) {
    if (template.legendaryActionBudget > 0) {
      const laRemaining = c.legendaryActionsRemaining !== undefined ? c.legendaryActionsRemaining : template.legendaryActionBudget;
      html += '<span class="la-badge">LA:' + laRemaining + '/' + template.legendaryActionBudget + '</span>';
    }
    if (template.legendaryResistances > 0) {
      const lrRemaining = c.legendaryResistancesRemaining !== undefined ? c.legendaryResistancesRemaining : template.legendaryResistances;
      html += '<span class="lr-badge">LR:' + lrRemaining + '/' + template.legendaryResistances + '</span>';
    }
  }
  // Condition chips (all combatant types)
  if (c.conditions && c.conditions.length > 0) {
    c.conditions.forEach(cond => {
      html += '<span class="condition-chip' + (cond.durationType === 'save' ? ' save-based' : '') + '">' + esc(cond.name);
      if (cond.durationType === 'rounds' && cond.duration) html += ' (' + cond.duration + ')';
      html += '</span>';
    });
  }
  if (c.concentration) {
    html += '<span class="concentration-chip">Conc: ' + esc(c.concentration) + '</span>';
  }
  // Turn-start notification badge (visible when panel closed)
  if (isCurrent && c.rollLog && c.rollLog.length > 0 && !c._expanded) {
    html += '<span class="turn-notify">' + c.rollLog.length + ' alert' + (c.rollLog.length !== 1 ? 's' : '') + '</span>';
  }
  html += '</span>';

  // AC
  if (c.type === 'monster' && template) {
    html += '<span class="ac-val">' + ovh(c, 'ac', '' + template.ac) + '</span>';
  } else if (c.type === 'player' && c.ac) {
    html += '<span class="ac-val">' + c.ac + '</span>';
  } else if (c.type === 'adhoc' && c.ac) {
    html += '<span class="ac-val">' + c.ac + '</span>';
  } else {
    html += '<span class="ac-val"></span>';
  }

  // HP bar (monsters and ad-hoc with HP)
  if ((c.type === 'monster' && template) || (c.type === 'adhoc' && c.hpMax)) {
    const hp = getCombatantHp(c, template);
    html += renderHpBar(hp.curHp, hp.maxHp, hp.tempHp);
  } else {
    html += '<span></span>';
  }

  // Reaction indicator
  if (c.type !== 'adhoc') {
    const rUsed = c.reactionUsed || false;
    html += '<span class="reaction-indicator ' + (rUsed ? 'used' : 'available') + '" onclick="event.stopPropagation();toggleReaction(' + idx + ')" title="' + (rUsed ? 'Reaction used' : 'Reaction available') + '">R</span>';
  } else {
    html += '<span></span>';
  }

  html += '</div>';

  // ── Detail Panel ──
  const expanded = c._expanded || false;
  html += '<div class="combatant-detail' + (expanded ? ' expanded' : '') + '" id="detail-' + idx + '">';
  html += renderCombatantDetail(c, idx, template);
  html += '</div>';

  return html;
}

function renderActiveCombat(el) {
  const combat = getActiveCombat();
  let html = '';

  // ── Combat Bar ──
  html += renderCombatBar(combat);

  // ── Combat Info Header ──
  html += renderCombatInfo(combat);

  // ── Edit Form or Combatant Rows ──
  if (editState.mode && editState.visible) {
    html += '<div id="editOverrideContainer"></div>';
    el.innerHTML = html;
    renderEditOverrideForm();
    return;
  }

  // ── Column Headers ──
  html += '<div class="combatant-row" style="border:none;background:none;cursor:default;padding:0.2rem 0.75rem;margin-bottom:0;min-height:0">';
  html += '<span class="ac-val" style="font-size:0.6rem;text-transform:uppercase;letter-spacing:0.05em">Init</span>';
  html += '<span style="font-size:0.6rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.05em">Name</span>';
  html += '<span class="ac-val" style="font-size:0.6rem;text-transform:uppercase;letter-spacing:0.05em">AC</span>';
  html += '<span style="font-size:0.6rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.05em">HP</span>';
  html += '<span style="font-size:0.6rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.05em;text-align:center">R</span>';
  html += '</div>';

  // ── Combatant Rows ──
  combat.combatants.forEach((c, idx) => {
    const template = getTemplate(c);
    html += renderCombatantRow(c, idx, template, combat);
  });

  el.innerHTML = html;
}

function renderMonsterDetail(c, idx, template) {
  let html = '';

  // Left column: HP + Features + Attacks + Roll Log
  html += '<div>';

  // HP Controls
  const maxHp = template.hpMax;
  const curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
  const tempHp = c.tempHp || 0;
  html += '<div class="detail-section-title">Hit Points</div>';
  html += '<div class="text-mono" style="margin-bottom:0.3rem">';
  html += '<strong>' + curHp + '</strong> / ' + ovh(c, 'hpMax', '' + maxHp);
  if (tempHp > 0) html += ' <span style="color:var(--accent)">(+' + tempHp + ' temp)</span>';
  html += '</div>';
  html += '<div class="hp-controls">';
  html += '<input type="number" id="hpInput-' + idx + '" placeholder="0" min="0" onclick="event.stopPropagation()">';
  html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();applyDamage(' + idx + ')">Dmg</button>';
  html += '<button class="btn-sm btn-success" onclick="event.stopPropagation();applyHeal(' + idx + ')">Heal</button>';
  html += '<button class="btn-sm btn-warning" onclick="event.stopPropagation();applyTempHp(' + idx + ')">THP</button>';
  html += '</div>';

  // Multiattack
  if (template.multiattack) {
    html += '<div class="multiattack-box">' + ovh(c, 'multiattack', 'Multiattack: ' + esc(template.multiattack)) + '</div>';
  }

  // Features (moved from right column)
  if (template.features.length > 0) {
    html += '<div class="detail-section-title" style="margin-top:0.5rem">Features</div>';
    template.features.forEach((f, fIdx) => {
      html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
      html += '<div style="font-size:0.75rem;display:flex;align-items:center;gap:0.4rem;flex-wrap:wrap">';
      html += '<strong>' + ovh(c, 'features.' + fIdx + '.name', esc(f.name)) + '</strong>';
      if (f.recharge) html += '<span style="color:var(--warning)">' + ovh(c, 'features.' + fIdx + '.recharge', '(Recharge ' + esc(f.recharge) + ')') + '</span>';
      if (f.usesMax) {
        const remaining = c.featureUses && c.featureUses[fIdx] !== undefined ? c.featureUses[fIdx] : f.usesMax;
        html += '<span style="font-family:var(--mono);font-size:0.72rem;color:' + (remaining === 0 ? 'var(--error)' : 'var(--text-dim)') + '">Uses: ' + remaining + '/' + f.usesMax + '</span>';
        html += '<button class="btn-sm btn-accent"' + (remaining <= 0 ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();useFeature(' + idx + ',' + fIdx + ')"' + (remaining <= 0 ? ' disabled' : '') + '>Use</button>';
        html += '<button class="btn-sm btn-success"' + (remaining >= f.usesMax ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();restoreFeature(' + idx + ',' + fIdx + ')"' + (remaining >= f.usesMax ? ' disabled' : '') + '>Restore</button>';
      }
      if (f.recharge && f.usesMax) {
        const remaining = c.featureUses && c.featureUses[fIdx] !== undefined ? c.featureUses[fIdx] : f.usesMax;
        if (remaining === 0) {
          html += '<button class="btn-sm btn-warning" onclick="event.stopPropagation();rollRecharge(' + idx + ',' + fIdx + ')">Roll Recharge</button>';
        }
      }
      html += '</div>';
      if (f.desc) {
        let fDescHtml = renderDiceText(esc(f.desc), idx, 'feature', fIdx);
        if (isFieldOverridden(c, 'features.' + fIdx + '.desc')) fDescHtml = '<span class="override-highlight">' + fDescHtml + '</span>';
        html += '<div style="font-size:0.72rem;color:var(--text-muted);margin-top:0.15rem">' + fDescHtml + '</div>';
      }
      html += '</div>';
    });
  }

  // Attacks
  if (template.attacks.length > 0) {
    html += '<div class="detail-section-title" style="margin-top:0.5rem">Attacks</div>';
    template.attacks.forEach((atk, atkIdx) => {
      html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
      html += '<div style="display:flex;align-items:center;gap:0.4rem;flex-wrap:wrap">';
      html += '<strong style="font-size:0.8rem">' + ovh(c, 'attacks.' + atkIdx + '.name', esc(atk.name)) + '</strong>';
      html += '<span style="font-family:var(--mono);font-size:0.72rem;color:var(--text-dim)">';
      html += ovh(c, 'attacks.' + atkIdx + '.bonus', (atk.bonus >= 0 ? '+' : '') + atk.bonus) + ' to hit';
      if (atk.note) html += ' &middot; ' + ovh(c, 'attacks.' + atkIdx + '.note', esc(atk.note));
      html += '</span>';
      html += '<div class="spacer"></div>';
      html += '<button class="btn-sm" onclick="showRollPopup(event,\'rollAttack\',' + idx + ',' + atkIdx + ')">Atk</button>';
      if (atk.damages && atk.damages.length > 0) {
        html += '<button class="btn-sm" onclick="showDmgPopup(event,' + idx + ',' + atkIdx + ')">Dmg</button>';
      }
      html += '</div>';
      // Damage summary
      if (atk.damages && atk.damages.length > 0) {
        html += '<div class="text-dim-sm" style="margin-top:0.15rem">';
        html += atk.damages.map(function(dm, dmIdx) { return ovh(c, 'attacks.' + atkIdx + '.damages.' + dmIdx + '.dice', esc(dm.dice)) + ' ' + ovh(c, 'attacks.' + atkIdx + '.damages.' + dmIdx + '.type', esc(dm.type)) + (dm.note ? ' (' + ovh(c, 'attacks.' + atkIdx + '.damages.' + dmIdx + '.note', esc(dm.note)) + ')' : ''); }).join(' + ');
        html += '</div>';
      }
      if (atk.desc) {
        let atkDescHtml = renderDiceText(esc(atk.desc), idx, 'attack', atkIdx);
        if (isFieldOverridden(c, 'attacks.' + atkIdx + '.desc')) atkDescHtml = '<span class="override-highlight">' + atkDescHtml + '</span>';
        html += '<div class="text-dim-sm" style="margin-top:0.15rem">' + atkDescHtml + '</div>';
      }
      html += '</div>';
    });
  }

  // Legendary Actions (left column - more room for long descriptions)
  if (template.legendaryActionBudget > 0 && template.legendaryActions.length > 0) {
    const laRemaining = c.legendaryActionsRemaining !== undefined ? c.legendaryActionsRemaining : template.legendaryActionBudget;
    html += '<div class="detail-section-title" style="margin-top:0.5rem">Legendary Actions <span style="font-family:var(--mono);color:var(--warning)">' + laRemaining + '/' + template.legendaryActionBudget + '</span>';
    html += ' <button class="btn-sm btn-success" style="font-size:0.65rem;padding:0.05rem 0.3rem' + (laRemaining >= template.legendaryActionBudget ? ';opacity:0.4' : '') + '" onclick="event.stopPropagation();restoreLegendaryAction(' + idx + ')"' + (laRemaining >= template.legendaryActionBudget ? ' disabled' : '') + '>Restore LA</button>';
    html += '</div>';
    template.legendaryActions.forEach((la, laIdx) => {
      const canUse = laRemaining >= la.cost;
      html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
      html += '<div style="font-size:0.75rem;display:flex;align-items:center;gap:0.4rem;flex-wrap:wrap">';
      html += '<strong>' + ovh(c, 'legendaryActions.' + laIdx + '.name', esc(la.name)) + '</strong>';
      html += '<span style="font-family:var(--mono);font-size:0.68rem;color:var(--text-dim)">' + ovh(c, 'legendaryActions.' + laIdx + '.cost', 'Cost: ' + la.cost) + '</span>';
      html += '<button class="btn-sm btn-accent"' + (!canUse ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();useLegendaryAction(' + idx + ',' + laIdx + ')"' + (!canUse ? ' disabled' : '') + '>Use</button>';
      html += '</div>';
      if (la.desc) {
        let laDescHtml = renderDiceText(esc(la.desc), idx, 'la', laIdx);
        if (isFieldOverridden(c, 'legendaryActions.' + laIdx + '.desc')) laDescHtml = '<span class="override-highlight">' + laDescHtml + '</span>';
        html += '<div style="font-size:0.72rem;color:var(--text-muted);margin-top:0.15rem">' + laDescHtml + '</div>';
      }
      html += '</div>';
    });
  }

  // Legendary Resistances (left column)
  if (template.legendaryResistances > 0) {
    const lrRemaining = c.legendaryResistancesRemaining !== undefined ? c.legendaryResistancesRemaining : template.legendaryResistances;
    html += '<div class="detail-section-title" style="margin-top:0.5rem">Legendary Resistances <span style="font-family:var(--mono);color:' + (lrRemaining === 0 ? 'var(--error)' : 'var(--text-dim)') + '">' + lrRemaining + '/' + template.legendaryResistances + '</span></div>';
    html += '<div style="display:flex;gap:0.3rem">';
    html += '<button class="btn-sm btn-accent"' + (lrRemaining <= 0 ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();useLegendaryResistance(' + idx + ')"' + (lrRemaining <= 0 ? ' disabled' : '') + '>Use LR</button>';
    html += '<button class="btn-sm btn-success"' + (lrRemaining >= template.legendaryResistances ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();restoreLegendaryResistance(' + idx + ')"' + (lrRemaining >= template.legendaryResistances ? ' disabled' : '') + '>Restore LR</button>';
    html += '</div>';
  }

  // Lair Actions (reference only)
  if (template.lairActions && template.lairActions.length > 0) {
    html += '<div class="detail-section-title" style="margin-top:0.5rem">Lair Actions</div>';
    template.lairActions.forEach((la, laIdx) => {
      html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
      html += '<div style="font-size:0.75rem"><strong>' + ovh(c, 'lairActions.' + laIdx + '.name', esc(la.name)) + '</strong></div>';
      if (la.desc) {
        let laDescHtml = renderDiceText(esc(la.desc), idx, 'lair', laIdx);
        if (isFieldOverridden(c, 'lairActions.' + laIdx + '.desc')) laDescHtml = '<span class="override-highlight">' + laDescHtml + '</span>';
        html += '<div style="font-size:0.72rem;color:var(--text-muted);margin-top:0.15rem">' + laDescHtml + '</div>';
      }
      html += '</div>';
    });
  }

  // Roll log
  html += '<div id="rollLog-' + idx + '">';
  if (c.rollLog && c.rollLog.length > 0) {
    html += '<div class="roll-log">';
    c.rollLog.forEach(entry => {
      html += '<div class="roll-log-entry ' + (entry.cssClass || '') + '">';
      html += '<strong>' + entry.label + ':</strong> ' + entry.text;
      html += '</div>';
    });
    html += '</div>';
  }
  html += '</div>';

  html += '</div>';

  // Right column: Reference + Roll
  html += '<div>';

  // Speed, Senses, Source, Gear
  html += '<div class="text-dim-sm" style="margin-bottom:0.4rem">';
  if (template.speed) html += 'Speed: ' + ovh(c, 'speed', esc(template.speed)) + '<br>';
  if (template.senses) html += 'Senses: ' + ovh(c, 'senses', esc(template.senses)) + '<br>';
  if (template.source) html += 'Source: ' + esc(template.source) + '<br>';
  if (template.gear) html += 'Gear: ' + esc(template.gear) + '<br>';
  html += '</div>';

  // Passives
  html += '<div class="passive-row">';
  html += '<span><span class="passive-label">PP </span>' + ovh(c, 'passivePerception', '' + getPassivePerception(template)) + '</span>';
  html += '<span><span class="passive-label">PI </span>' + calcPassiveInvestigation(template) + '</span>';
  html += '<span><span class="passive-label">PIn </span>' + calcPassiveInsight(template) + '</span>';
  html += '</div>';

  // Checks & Saves grid
  html += '<div class="detail-section-title">Checks & Saves</div>';
  for (let attrRow = 0; attrRow < 2; attrRow++) {
    html += '<div class="attr-grid">';
    for (let attrCol = 0; attrCol < 3; attrCol++) {
      const ab = ABILITIES[attrRow * 3 + attrCol];
      const score = template.abilities[ab];
      const mod = abilityMod(score);
      const st = template.savingThrows && template.savingThrows.find(function(s) { return s.ability === ab; });
      const saveMod = st ? st.bonus : mod;
      const saveProfClass = st ? ' proficient' : '';

      html += '<div class="attr-cell">';
      html += '<span class="attr-label">' + ab.toUpperCase() + '</span>';
      // Check button: score (+mod)
      html += '<button class="attr-btn" onclick="showRollPopup(event,\'rollAbilityCheck\',' + idx + ',\'' + ab + '\')">';
      html += ovh(c, 'abilities.' + ab, score + ' (' + modStr(score) + ')');
      html += '</button>';
      // Save sub-label + button
      html += '<span class="attr-sub">save</span>';
      let saveDisplay = (saveMod >= 0 ? '+' : '') + saveMod;
      const rawT = getRawTemplate(c);
      if (rawT && isFieldOverridden(c, 'savingThrows')) {
        const rawSt = rawT.savingThrows && rawT.savingThrows.find(function(s) { return s.ability === ab; });
        const rawSaveMod = rawSt ? rawSt.bonus : abilityMod(rawT.abilities[ab]);
        if (saveMod !== rawSaveMod) saveDisplay = '<span class="override-highlight">' + saveDisplay + '</span>';
      }
      html += '<button class="attr-btn save-btn' + saveProfClass + '" onclick="showRollPopup(event,\'rollSavingThrow\',' + idx + ',\'' + ab + '\')">';
      html += saveDisplay;
      html += '</button>';
      html += '</div>';
    }
    html += '</div>';
  }

  // Skills grid
  html += '<div class="detail-section-title" style="margin-top:0.75rem">Skills</div>';
  html += '<div class="skill-grid">';
  SKILLS.forEach(function(skillName, skillIdx) {
    const skillAbility = SKILL_ABILITY_MAP[skillName];
    const skill = template.skills.find(function(s) { return s.name === skillName; });
    const skillMod = skill ? skill.bonus : abilityMod(template.abilities[skillAbility]);
    const skillProfClass = skill ? ' proficient' : '';
    let skillDisplay = (skillMod >= 0 ? '+' : '') + skillMod;
    if (isFieldOverridden(c, 'skills')) {
      const rawT2 = getRawTemplate(c);
      if (rawT2) {
        const rawSkill = rawT2.skills.find(function(s) { return s.name === skillName; });
        const rawSkillMod = rawSkill ? rawSkill.bonus : abilityMod(rawT2.abilities[skillAbility]);
        if (skillMod !== rawSkillMod) skillDisplay = '<span class="override-highlight">' + skillDisplay + '</span>';
      }
    }

    html += '<div class="skill-cell">';
    html += '<span class="skill-label">' + esc(skillName) + '</span>';
    html += '<button class="attr-btn' + skillProfClass + '" onclick="showRollPopup(event,\'rollSkillCheck\',' + idx + ',' + skillIdx + ')">';
    html += skillDisplay;
    html += '</button>';
    html += '</div>';
  });
  html += '</div>';

  html += '</div>';

  return html;
}

function renderPlayerDetail(c, idx) {
  let html = '';
  html += '<div><div class="detail-section-title">Player</div>';
  html += '<div class="flex-row" style="margin-bottom:0.3rem">';
  html += '<label style="font-size:0.75rem;color:var(--text-muted)">AC</label>';
  html += '<input type="number" value="' + (c.ac || '') + '" style="width:60px;padding:0.25rem 0.4rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-family:var(--mono);font-size:0.78rem;text-align:center" onchange="event.stopPropagation();setPlayerAc(' + idx + ',+this.value)" onclick="event.stopPropagation()" placeholder="-">';
  html += '</div>';
  html += '<div class="text-muted-sm">Conditions and details tracked by the DM.</div>';
  html += '</div><div></div>';
  return html;
}

function renderAdhocDetail(c, idx) {
  let html = '';
  html += '<div><div class="detail-section-title">Ad-hoc Combatant</div>';
  html += '<div class="detail-label">Lair action, environment effect, or custom entry.</div>';
  // HP controls (if hpMax set)
  if (c.hpMax) {
    const maxHp = c.hpMax;
    const curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
    const tempHp = c.tempHp || 0;
    html += '<div class="detail-section-title">Hit Points</div>';
    html += '<div class="text-mono" style="margin-bottom:0.3rem">';
    html += '<strong>' + curHp + '</strong> / ' + maxHp;
    if (tempHp > 0) html += ' <span style="color:var(--accent)">(+' + tempHp + ' temp)</span>';
    html += '</div>';
    html += '<div class="hp-controls">';
    html += '<input type="number" id="hpInput-' + idx + '" placeholder="0" min="0" onclick="event.stopPropagation()">';
    html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();applyDamage(' + idx + ')">Dmg</button>';
    html += '<button class="btn-sm btn-success" onclick="event.stopPropagation();applyHeal(' + idx + ')">Heal</button>';
    html += '<button class="btn-sm btn-warning" onclick="event.stopPropagation();applyTempHp(' + idx + ')">THP</button>';
    html += '</div>';
  }
  // AC display (if set)
  if (c.ac) {
    html += '<div class="detail-label"><strong>AC</strong> ' + c.ac + '</div>';
  }
  // Roll log
  html += '<div id="rollLog-' + idx + '">';
  if (c.rollLog && c.rollLog.length > 0) {
    html += '<div class="roll-log">';
    c.rollLog.forEach(function(entry) {
      html += '<div class="roll-log-entry ' + (entry.cssClass || '') + '">';
      html += '<strong>' + entry.label + ':</strong> ' + entry.text;
      html += '</div>';
    });
    html += '</div>';
  }
  html += '</div>';
  html += '</div><div></div>';
  return html;
}

function renderCombatantDetail(c, idx, template) {
  let html = '<div class="detail-grid">';

  if (c.type === 'monster' && template) {
    html += renderMonsterDetail(c, idx, template);
  } else if (c.type === 'player') {
    html += renderPlayerDetail(c, idx);
  } else {
    html += renderAdhocDetail(c, idx);
  }

  html += '</div>'; // end detail-grid

  // Common controls for all types
  html += '<div style="display:flex;gap:0.5rem;margin-top:0.5rem;align-items:flex-end;flex-wrap:wrap">';
  html += '<div class="form-field" style="width:80px"><label>Init</label>';
  html += '<input type="number" step="0.01" value="' + (c.init !== null && c.init !== undefined ? c.init : '') + '" onchange="event.stopPropagation();editInit(' + idx + ',this.value)" onclick="event.stopPropagation()">';
  html += '</div>';
  html += '<div class="form-field" style="flex:1"><label>Notes</label>';
  html += '<input type="text" value="' + esc(c.notes || '') + '" onchange="event.stopPropagation();setCombatantNotes(' + idx + ',this.value)" onclick="event.stopPropagation()" placeholder="DM notes...">';
  html += '</div>';
  if (c.dead) {
    html += '<button class="btn-sm btn-success" onclick="event.stopPropagation();reviveCombatant(' + idx + ')">Revive</button>';
  } else {
    html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();killCombatant(' + idx + ')">Kill</button>';
  }
  html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();removeCombatant(' + idx + ')">Remove</button>';
  if (c.type === 'monster') {
    html += '<button class="btn-sm btn-accent" onclick="event.stopPropagation();editSingleCombatant(' + idx + ')">Edit</button>';
  }
  html += '</div>';

  // ── Conditions (all combatant types) ──
  html += '<div style="margin-top:0.5rem">';
  html += '<div class="detail-section-title">Conditions</div>';
  // Existing conditions
  if (c.conditions && c.conditions.length > 0) {
    html += '<div style="display:flex;flex-wrap:wrap;gap:0.3rem;margin-bottom:0.4rem">';
    c.conditions.forEach((cond, condIdx) => {
      html += '<span class="condition-chip' + (cond.durationType === 'save' ? ' save-based' : '') + '" style="font-size:0.68rem;padding:0.15rem 0.4rem">';
      html += esc(cond.name);
      if (cond.durationType === 'rounds' && cond.duration) html += ' (' + cond.duration + 'r)';
      if (cond.durationType === 'save') html += ' (' + cond.saveAbility.toUpperCase() + ' DC' + cond.saveDC + ')';
      if (cond.source) html += ' [' + esc(cond.source) + ']';
      html += ' <button class="btn-remove" style="padding:0.05rem 0.3rem;font-size:0.6rem;margin-left:0.15rem;vertical-align:middle" onclick="event.stopPropagation();removeCondition(' + idx + ',' + condIdx + ')">×</button>';
      html += '</span>';
    });
    html += '</div>';
  }
  // Add condition form
  html += '<div style="display:flex;gap:0.3rem;align-items:flex-end;flex-wrap:wrap;font-size:0.72rem">';
  html += '<select id="condName-' + idx + '" onclick="event.stopPropagation()" onchange="event.stopPropagation();toggleCustomCondInput(' + idx + ')" style="padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
  CONDITIONS.forEach(cn => { html += '<option value="' + cn + '">' + cn + '</option>'; });
  html += '<option value="__custom__">Custom...</option>';
  html += '</select>';
  html += '<input type="text" id="condCustomName-' + idx + '" placeholder="Effect name" onclick="event.stopPropagation()" style="display:none;width:90px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
  html += '<select id="condType-' + idx + '" onclick="event.stopPropagation()" onchange="event.stopPropagation();updateConditionFields(' + idx + ')" style="padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
  html += '<option value="rounds">Rounds</option>';
  html += '<option value="save">Save-based</option>';
  html += '<option value="indefinite">Indefinite</option>';
  html += '</select>';
  html += '<span id="condFields-' + idx + '">';
  html += '<input type="number" id="condDur-' + idx + '" placeholder="rounds" min="1" value="1" onclick="event.stopPropagation()" style="width:55px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem;font-family:var(--mono)">';
  html += '</span>';
  html += '<input type="text" id="condSrc-' + idx + '" placeholder="source" onclick="event.stopPropagation()" style="width:70px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
  html += '<button class="btn-sm btn-accent" onclick="event.stopPropagation();addCondition(' + idx + ')">Add</button>';
  html += '</div>';
  html += '</div>';

  // ── Concentration (all combatant types) ──
  if (c.type !== 'adhoc') {
    html += '<div class="flex-row-tight" style="margin-top:0.4rem">';
    html += '<span class="detail-section-title" style="margin-bottom:0">Concentration</span>';
    html += '<input type="text" id="concInput-' + idx + '" value="' + esc(c.concentration || '') + '" placeholder="Spell name..." onclick="event.stopPropagation()" onchange="event.stopPropagation();setConcentration(' + idx + ',this.value)" style="flex:1;padding:0.25rem 0.4rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
    if (c.concentration) {
      html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();dropConcentration(' + idx + ')" style="font-size:0.68rem">Drop</button>';
    }
    html += '</div>';
  }

  // ── Tactics & Descriptions accordion (monsters only) ──
  if (c.type === 'monster' && template && (template.tactics || template.playerDescription || template.dmDescription)) {
    const descId = 'desc-accordion-' + idx;
    html += '<div class="detail-accordion-toggle" onclick="event.stopPropagation();toggleDescAccordion(' + idx + ')" id="' + descId + '-toggle">';
    html += '<span class="arrow">&#9654;</span> Tactics & Descriptions';
    html += '</div>';
    html += '<div class="detail-accordion-body" id="' + descId + '-body">';
    if (template.tactics) {
      html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
      html += '<div style="display:flex;align-items:center;gap:0.3rem;margin-bottom:0.15rem"><span style="font-size:0.68rem;font-weight:700;color:var(--text-muted)">Tactics</span><div class="spacer"></div>';
      html += '<button class="btn-sm" onclick="event.stopPropagation();copyDescText(this,\'tactics\',' + idx + ')" style="font-size:0.6rem;padding:0.1rem 0.4rem">Copy</button></div>';
      html += '<div style="font-size:0.75rem;color:var(--text-muted);white-space:pre-wrap">' + ovh(c, 'tactics', esc(template.tactics)) + '</div></div>';
    }
    if (template.playerDescription) {
      html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
      html += '<div style="display:flex;align-items:center;gap:0.3rem;margin-bottom:0.15rem"><span style="font-size:0.68rem;font-weight:700;color:var(--accent)">Player Description</span><div class="spacer"></div>';
      html += '<button class="btn-sm" onclick="event.stopPropagation();copyDescText(this,\'player\',' + idx + ')" style="font-size:0.6rem;padding:0.1rem 0.4rem">Copy</button></div>';
      html += '<div style="font-size:0.75rem;color:var(--text-muted);white-space:pre-wrap">' + ovh(c, 'playerDescription', esc(template.playerDescription)) + '</div></div>';
    }
    if (template.dmDescription) {
      html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
      html += '<div style="display:flex;align-items:center;gap:0.3rem;margin-bottom:0.15rem"><span style="font-size:0.68rem;font-weight:700;color:var(--warning)">DM Description</span><div class="spacer"></div>';
      html += '<button class="btn-sm" onclick="event.stopPropagation();copyDescText(this,\'dm\',' + idx + ')" style="font-size:0.6rem;padding:0.1rem 0.4rem">Copy</button></div>';
      html += '<div style="font-size:0.75rem;color:var(--text-muted);white-space:pre-wrap">' + ovh(c, 'dmDescription', esc(template.dmDescription)) + '</div></div>';
    }
    html += '</div>';
  }

  return html;
}

function toggleDescAccordion(idx) {
  const toggle = document.getElementById('desc-accordion-' + idx + '-toggle');
  const body = document.getElementById('desc-accordion-' + idx + '-body');
  if (toggle && body) {
    toggle.classList.toggle('open');
    body.classList.toggle('open');
  }
}

function copyCombatField(btn, field) {
  const combat = getActiveCombat();
  let text = '';
  if (field === 'party') {
    const party = state.parties.find(function(p) { return p.id === combat.partyId; });
    text = party ? party.name : '';
  } else {
    const enc = state.encounters.find(function(e) { return e.id === combat.encounterId; });
    text = enc ? enc[field] || '' : '';
  }
  if (!text) return;
  navigator.clipboard.writeText(text).then(function() {
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(function() { btn.textContent = orig; }, 1200);
  });
}

function copyDescText(btn, type, idx) {
  const combat = getActiveCombat();
  const c = combat.combatants[idx];
  const t = getTemplate(c);
  if (!t) return;
  const text = type === 'tactics' ? t.tactics : type === 'player' ? t.playerDescription : t.dmDescription;
  if (!text) return;
  navigator.clipboard.writeText(text).then(function() {
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(function() { btn.textContent = orig; }, 1200);
  });
}

function toggleCombatantDetail(idx) {
  const combat = getActiveCombat();
  const c = combat.combatants[idx];
  // Prevent collapsing the active combatant during their turn
  if (c._expanded && combat.round >= 1 && idx === combat.turnIndex) return;
  c._expanded = !c._expanded;
  // If manually collapsing a panel that was auto-expanded, clear the tracking
  if (!c._expanded && autoExpandedId === c.id) autoExpandedId = null;
  const detailEl = document.getElementById('detail-' + idx);
  if (detailEl) {
    detailEl.classList.toggle('expanded', c._expanded);
  }
}

function setCombatantNotes(idx, value) {
  const c = getCombatant(idx);
  if (!c) return;
  c.notes = value;
  saveCombat();
}

function setPlayerAc(idx, value) {
  const c = getCombatant(idx);
  if (!c) return;
  c.ac = value || 0;
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Condition Tracking ──
// ═══════════════════════════════════════════════════════════════

function toggleCustomCondInput(idx) {
  const nameEl = document.getElementById('condName-' + idx);
  const customEl = document.getElementById('condCustomName-' + idx);
  if (!nameEl || !customEl) return;
  if (nameEl.value === '__custom__') {
    customEl.style.display = '';
    customEl.focus();
  } else {
    customEl.style.display = 'none';
    customEl.value = '';
  }
}

function updateConditionFields(idx) {
  const typeEl = document.getElementById('condType-' + idx);
  const fieldsEl = document.getElementById('condFields-' + idx);
  if (!typeEl || !fieldsEl) return;
  const dtype = typeEl.value;
  if (dtype === 'rounds') {
    fieldsEl.innerHTML = '<input type="number" id="condDur-' + idx + '" placeholder="rounds" min="1" value="1" onclick="event.stopPropagation()" style="width:55px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem;font-family:var(--mono)">';
  } else if (dtype === 'save') {
    fieldsEl.innerHTML = '<select id="condSaveAb-' + idx + '" onclick="event.stopPropagation()" style="padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">' +
      ABILITIES.map(ab => '<option value="' + ab + '">' + ab.toUpperCase() + '</option>').join('') +
      '</select>' +
      '<input type="number" id="condSaveDC-' + idx + '" placeholder="DC" min="1" value="15" onclick="event.stopPropagation()" style="width:45px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem;font-family:var(--mono)">';
  } else {
    fieldsEl.innerHTML = '';
  }
}

function addCondition(idx) {
  const c = getCombatant(idx);
  if (!c) return;
  const nameEl = document.getElementById('condName-' + idx);
  const typeEl = document.getElementById('condType-' + idx);
  if (!nameEl || !typeEl) return;

  let name = nameEl.value;
  if (name === '__custom__') {
    const customEl = document.getElementById('condCustomName-' + idx);
    name = customEl && customEl.value.trim();
    if (!name) { setStatus('Enter a custom condition name.', 'error'); return; }
  }

  const durationType = typeEl.value;
  const condition = { name, durationType, source: '' };

  const srcEl = document.getElementById('condSrc-' + idx);
  if (srcEl && srcEl.value.trim()) condition.source = srcEl.value.trim();

  if (durationType === 'rounds') {
    const durEl = document.getElementById('condDur-' + idx);
    condition.duration = Math.max(1, parseInt(durEl && durEl.value) || 1);
  } else if (durationType === 'save') {
    const abEl = document.getElementById('condSaveAb-' + idx);
    const dcEl = document.getElementById('condSaveDC-' + idx);
    condition.saveAbility = abEl ? abEl.value : 'con';
    condition.saveDC = Math.max(1, parseInt(dcEl && dcEl.value) || 15);
  }

  if (!c.conditions) c.conditions = [];
  c.conditions.push(condition);
  setStatus(c.name + ': ' + name + ' condition added', 'success');
  saveCombat();
  render();
}

function removeCondition(idx, condIdx) {
  const c = getCombatant(idx);
  if (!c) return;
  if (!c.conditions || !c.conditions[condIdx]) return;
  const name = c.conditions[condIdx].name;
  c.conditions.splice(condIdx, 1);
  setStatus(c.name + ': ' + name + ' condition removed', 'success');
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Concentration Tracking ──
// ═══════════════════════════════════════════════════════════════

function setConcentration(idx, spellName) {
  const c = getCombatant(idx);
  if (!c) return;
  c.concentration = spellName.trim() || null;
  if (c.concentration) {
    setStatus(c.name + ' concentrating on ' + c.concentration, 'success');
  }
  saveCombat();
  render();
}

function dropConcentration(idx) {
  const c = getCombatant(idx);
  if (!c) return;
  const spell = c.concentration;
  c.concentration = null;
  setStatus(c.name + ' dropped concentration' + (spell ? ' on ' + spell : ''), 'warning');
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── HP Tracking ──
// ═══════════════════════════════════════════════════════════════

function applyDamage(idx) {
  const input = document.getElementById('hpInput-' + idx);
  if (!input) return;
  const originalDmg = Math.max(0, parseInt(input.value) || 0);
  let dmg = originalDmg;
  if (dmg === 0) return;

  const c = getCombatant(idx);
  if (!c) return;
  const template = getTemplate(c);
  const maxHp = template ? template.hpMax : (c.hpMax || c.currentHp);

  // THP absorbs first
  let tempHp = c.tempHp || 0;
  if (tempHp > 0) {
    const absorbed = Math.min(tempHp, dmg);
    tempHp -= absorbed;
    dmg -= absorbed;
    c.tempHp = tempHp;
  }

  let curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
  curHp -= dmg;
  c.currentHp = Math.max(curHp, 0);

  if (c.currentHp <= 0) {
    c.currentHp = 0;
    c.dead = true;
    setStatus(c.name + ' drops to 0 HP!', 'warning');
  } else {
    setStatus(c.name + ' takes damage. HP: ' + c.currentHp + '/' + maxHp, 'success');
  }

  // Concentration check warning
  if (c.concentration && originalDmg > 0) {
    const dc = Math.max(10, Math.floor(originalDmg / 2));
    setStatus(c.name + ' is concentrating on ' + c.concentration + '! CON save DC ' + dc + ' needed', 'warning');
  }

  saveCombat();
  render();
}

function applyHeal(idx) {
  const input = document.getElementById('hpInput-' + idx);
  if (!input) return;
  const heal = Math.max(0, parseInt(input.value) || 0);
  if (heal === 0) return;

  const c = getCombatant(idx);
  if (!c) return;
  const template = getTemplate(c);
  const maxHp = template ? template.hpMax : (c.hpMax || c.currentHp);
  let curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
  curHp = Math.min(curHp + heal, maxHp);
  c.currentHp = curHp;

  if (curHp > 0 && c.dead) c.dead = false;

  setStatus(c.name + ' healed. HP: ' + curHp + '/' + maxHp, 'success');
  saveCombat();
  render();
}

function applyTempHp(idx) {
  const input = document.getElementById('hpInput-' + idx);
  if (!input) return;
  const val = Math.max(0, parseInt(input.value) || 0);
  if (val === 0) return;
  const c = getCombatant(idx);
  if (!c) return;
  // THP doesn't stack - take the higher value
  c.tempHp = Math.max(c.tempHp || 0, val);
  setStatus(c.name + ' gains ' + val + ' temp HP', 'success');
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Feature Use Tracking ──
// ═══════════════════════════════════════════════════════════════

function useFeature(combatantIdx, featureIdx) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  const f = template.features[featureIdx];
  if (!f || !f.usesMax) return;
  if (!c.featureUses) c.featureUses = {};
  if (c.featureUses[featureIdx] === undefined) c.featureUses[featureIdx] = f.usesMax;
  if (c.featureUses[featureIdx] <= 0) return;
  c.featureUses[featureIdx]--;
  setStatus(c.name + ': ' + f.name + ' used (' + c.featureUses[featureIdx] + '/' + f.usesMax + ')', 'success');
  saveCombat();
  render();
}

function restoreFeature(combatantIdx, featureIdx) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  const f = template.features[featureIdx];
  if (!f || !f.usesMax) return;
  if (!c.featureUses) c.featureUses = {};
  if (c.featureUses[featureIdx] === undefined) c.featureUses[featureIdx] = f.usesMax;
  if (c.featureUses[featureIdx] >= f.usesMax) return;
  c.featureUses[featureIdx]++;
  setStatus(c.name + ': ' + f.name + ' restored (' + c.featureUses[featureIdx] + '/' + f.usesMax + ')', 'success');
  saveCombat();
  render();
}

function rollRecharge(combatantIdx, featureIdx) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  const f = template.features[featureIdx];
  if (!f || !f.recharge) return;
  const threshold = parseInt(f.recharge) || 6;
  const result = rollDice('1d6');
  if (!c.rollLog) c.rollLog = [];
  if (!c.featureUses) c.featureUses = {};
  if (result.total >= threshold) {
    c.featureUses[featureIdx] = f.usesMax || 1;
    c.rollLog.push({ label: 'Recharge: ' + esc(f.name), text: 'Rolled ' + result.total + ' (need ' + threshold + '+) - Recharged!', cssClass: 'crit' });
    setStatus(f.name + ' recharged!', 'success');
  } else {
    c.rollLog.push({ label: 'Recharge: ' + esc(f.name), text: 'Rolled ' + result.total + ' (need ' + threshold + '+) - No recharge', cssClass: 'fumble' });
    setStatus(f.name + ' did not recharge', 'warning');
  }
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Legendary Actions & Resistances ──
// ═══════════════════════════════════════════════════════════════

function useLegendaryAction(combatantIdx, laIdx) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  const la = template.legendaryActions[laIdx];
  if (!la) return;
  if (c.legendaryActionsRemaining === undefined) c.legendaryActionsRemaining = template.legendaryActionBudget;
  if (c.legendaryActionsRemaining < la.cost) return;
  c.legendaryActionsRemaining -= la.cost;
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: 'Legendary Action', text: esc(la.name) + ' (cost ' + la.cost + ') - LA ' + c.legendaryActionsRemaining + '/' + template.legendaryActionBudget + ' remaining', cssClass: '' });
  setStatus(c.name + ': ' + la.name + ' (LA ' + c.legendaryActionsRemaining + '/' + template.legendaryActionBudget + ')', 'success');
  saveCombat();
  render();
}

function useLegendaryResistance(combatantIdx) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  if (c.legendaryResistancesRemaining === undefined) c.legendaryResistancesRemaining = template.legendaryResistances;
  if (c.legendaryResistancesRemaining <= 0) return;
  c.legendaryResistancesRemaining--;
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: 'Legendary Resistance', text: 'Used - LR ' + c.legendaryResistancesRemaining + '/' + template.legendaryResistances + ' remaining', cssClass: '' });
  setStatus(c.name + ' uses Legendary Resistance (LR ' + c.legendaryResistancesRemaining + '/' + template.legendaryResistances + ')', 'warning');
  saveCombat();
  render();
}

function restoreLegendaryResistance(combatantIdx) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  if (c.legendaryResistancesRemaining === undefined) c.legendaryResistancesRemaining = template.legendaryResistances;
  if (c.legendaryResistancesRemaining >= template.legendaryResistances) return;
  c.legendaryResistancesRemaining++;
  setStatus(c.name + ': LR restored (' + c.legendaryResistancesRemaining + '/' + template.legendaryResistances + ')', 'success');
  saveCombat();
  render();
}

function restoreLegendaryAction(combatantIdx) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  if (c.legendaryActionsRemaining === undefined) c.legendaryActionsRemaining = template.legendaryActionBudget;
  if (c.legendaryActionsRemaining >= template.legendaryActionBudget) return;
  c.legendaryActionsRemaining++;
  setStatus(c.name + ': LA restored (' + c.legendaryActionsRemaining + '/' + template.legendaryActionBudget + ')', 'success');
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Ability Check / Save Rolling ──
// ═══════════════════════════════════════════════════════════════

// ── Roll Mode Popup ──
let rollPopupState = null;

function positionPopup(popup, target) {
  const rect = target.getBoundingClientRect();
  popup.style.display = 'flex';
  // Measure popup dimensions
  const pw = popup.offsetWidth;
  const ph = popup.offsetHeight;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  // Horizontal: default to button left, shift left if it overflows right edge
  let left = rect.left;
  if (left + pw > vw - 8) left = vw - pw - 8;
  if (left < 8) left = 8;
  // Vertical: default below button, flip above if it overflows bottom
  let top = rect.bottom + 4;
  if (top + ph > vh - 8) top = rect.top - ph - 4;
  if (top < 8) top = 8;
  popup.style.left = left + 'px';
  popup.style.top = top + 'px';
}

function showRollPopup(evt, rollFnName, combatantIdx, param) {
  evt.stopPropagation();
  rollPopupState = { fnName: rollFnName, idx: combatantIdx, param: param };
  const popup = document.getElementById('rollModePopup');
  if (!popup) return;
  popup.innerHTML =
    '<button class="btn-sm btn-danger" onclick="fireRollPopup(\'disadvantage\')">Disadvantage</button>' +
    '<button class="btn-sm" onclick="fireRollPopup()">Normal</button>' +
    '<button class="btn-sm btn-success" onclick="fireRollPopup(\'advantage\')">Advantage</button>';
  positionPopup(popup, evt.target);
}

function showDmgPopup(evt, combatantIdx, attackIdx) {
  evt.stopPropagation();
  rollPopupState = { idx: combatantIdx, param: attackIdx };
  const popup = document.getElementById('rollModePopup');
  if (!popup) return;
  popup.innerHTML =
    '<button class="btn-sm" onclick="fireDmgPopup(false)">Normal</button>' +
    '<button class="btn-sm btn-success" onclick="fireDmgPopup(true)">Crit</button>';
  positionPopup(popup, evt.target);
}

function fireRollPopup(mode) {
  if (!rollPopupState) return;
  const s = rollPopupState;
  hideRollPopup();
  window[s.fnName](s.idx, s.param, mode);
}

function fireDmgPopup(crit) {
  if (!rollPopupState) return;
  const s = rollPopupState;
  hideRollPopup();
  rollDamageForAttack(s.idx, s.param, crit);
}

function hideRollPopup() {
  rollPopupState = null;
  const popup = document.getElementById('rollModePopup');
  if (popup) popup.style.display = 'none';
}

document.addEventListener('click', hideRollPopup);

function rollAbilityCheck(combatantIdx, ability, mode) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  const mod = abilityMod(template.abilities[ability]);
  const notation = '1d20' + (mod >= 0 ? '+' + mod : String(mod));
  const opts = mode === 'advantage' ? { advantage: true } : mode === 'disadvantage' ? { disadvantage: true } : {};
  const result = rollDice(notation, opts);
  const modeLabel = mode === 'advantage' ? ' (Adv)' : mode === 'disadvantage' ? ' (Dis)' : '';
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: ability.toUpperCase() + ' Check' + modeLabel, text: esc(result.text) + ' = ' + result.total, cssClass: '' });
  saveCombat();
  renderRollLog(combatantIdx);
}

function rollSavingThrow(combatantIdx, ability, mode) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  // Check for proficient saving throw
  const st = template.savingThrows && template.savingThrows.find(s => s.ability === ability);
  const mod = st ? st.bonus : abilityMod(template.abilities[ability]);
  const notation = '1d20' + (mod >= 0 ? '+' + mod : String(mod));
  const opts = mode === 'advantage' ? { advantage: true } : mode === 'disadvantage' ? { disadvantage: true } : {};
  const result = rollDice(notation, opts);
  const modeLabel = mode === 'advantage' ? ' (Adv)' : mode === 'disadvantage' ? ' (Dis)' : '';
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: ability.toUpperCase() + ' Save' + (st ? ' (prof)' : '') + modeLabel, text: esc(result.text) + ' = ' + result.total, cssClass: '' });
  saveCombat();
  renderRollLog(combatantIdx);
}

function rollSkillCheck(combatantIdx, skillIdx, mode) {
  const skillName = SKILLS[skillIdx];
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  const ability = SKILL_ABILITY_MAP[skillName];
  const skill = template.skills.find(function(s) { return s.name === skillName; });
  const mod = skill ? skill.bonus : abilityMod(template.abilities[ability]);
  const notation = '1d20' + (mod >= 0 ? '+' + mod : String(mod));
  const opts = mode === 'advantage' ? { advantage: true } : mode === 'disadvantage' ? { disadvantage: true } : {};
  const result = rollDice(notation, opts);
  const modeLabel = mode === 'advantage' ? ' (Adv)' : mode === 'disadvantage' ? ' (Dis)' : '';
  const profLabel = skill ? ' (prof)' : '';
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: skillName + profLabel + modeLabel, text: esc(result.text) + ' = ' + result.total, cssClass: '' });
  saveCombat();
  renderRollLog(combatantIdx);
}

// ═══════════════════════════════════════════════════════════════
// ── Attack Rolling ──
// ═══════════════════════════════════════════════════════════════

function rollAttack(combatantIdx, attackIdx, mode) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  const atk = template.attacks[attackIdx];
  if (!atk) return;

  if (!c.rollLog) c.rollLog = [];
  const notation = '1d20' + (atk.bonus >= 0 ? '+' + atk.bonus : String(atk.bonus));
  const opts = mode === 'advantage' ? { advantage: true } : mode === 'disadvantage' ? { disadvantage: true } : {};
  const result = rollDice(notation, opts);
  const d20 = mode ? (result.rolls.length === 2 ? (mode === 'advantage' ? Math.max(...result.rolls) : Math.min(...result.rolls)) : result.rolls[0]) : result.rolls[0];
  const critThreshold = template.critRange || 20;
  const isCrit = d20 >= critThreshold;
  const critClass = isCrit ? 'crit' : d20 === 1 ? 'fumble' : '';
  const critLabel = isCrit ? ' - NAT 20!' : d20 === 1 ? ' - NAT 1' : '';
  const modeLabel = mode === 'advantage' ? ' (Adv)' : mode === 'disadvantage' ? ' (Dis)' : '';

  c.rollLog.push({
    label: esc(atk.name) + ' Attack' + modeLabel,
    text: esc(result.text) + ' (total: ' + result.total + ')' + critLabel,
    cssClass: critClass
  });
  saveCombat();
  renderRollLog(combatantIdx);
}

function rollDamageForAttack(combatantIdx, attackIdx, crit) {
  const c = getCombatant(combatantIdx);
  if (!c) return;
  const template = getTemplate(c);
  if (!template) return;
  const atk = template.attacks[attackIdx];
  if (!atk || !atk.damages || atk.damages.length === 0) return;

  if (!c.rollLog) c.rollLog = [];
  let parts = [];
  let grandTotal = 0;
  atk.damages.forEach(dm => {
    if (!dm.dice || !dm.dice.trim()) return;
    let dice = dm.dice.trim();
    if (crit) {
      // Double the dice count: NdM+X → (2N)dM+X
      const m = dice.match(/^(\d+)(d\d+.*)$/i);
      if (m) dice = (parseInt(m[1]) * 2) + m[2];
    }
    const result = rollDice(dice);
    grandTotal += result.total;
    let text = result.total + ' ' + (dm.type || 'untyped');
    text += ' (' + result.text + ')';
    if (dm.note) text += ' [' + dm.note + ']';
    parts.push(text);
  });

  c.rollLog.push({
    label: esc(atk.name) + (crit ? ' Crit Damage' : ' Damage'),
    text: esc(parts.join(' + ')) + ' = ' + grandTotal,
    cssClass: crit ? 'crit' : ''
  });
  saveCombat();
  renderRollLog(combatantIdx);
}

function renderRollLog(combatantIdx) {
  const el = document.getElementById('rollLog-' + combatantIdx);
  if (!el) return;
  const c = getCombatant(combatantIdx);
  if (!c) return;
  if (!c.rollLog || c.rollLog.length === 0) { el.innerHTML = ''; return; }
  let html = '<div class="roll-log">';
  c.rollLog.forEach(entry => {
    html += '<div class="roll-log-entry ' + (entry.cssClass || '') + '">';
    html += '<strong>' + entry.label + ':</strong> ' + entry.text;
    html += '</div>';
  });
  html += '</div>';
  el.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Turn Management ──
// ═══════════════════════════════════════════════════════════════

function applyTurnStartEffects(idx) {
  const c = getCombatant(idx);
  if (!c) return;
  const template = getTemplate(c);
  c.reactionUsed = false;
  c.rollLog = [];

  // Feature recharge prompts (DM-initiated)
  if (template && template.features) {
    template.features.forEach((f, fIdx) => {
      if (f.recharge && f.usesMax) {
        const remaining = c.featureUses && c.featureUses[fIdx] !== undefined ? c.featureUses[fIdx] : f.usesMax;
        if (remaining === 0) {
          c.rollLog.push({ label: 'Recharge Available', text: esc(f.name) + ' - open detail panel to Roll Recharge', cssClass: '' });
        }
      }
    });
  }

  // Legendary action recharge
  if (template && template.legendaryActionBudget > 0) {
    c.legendaryActionsRemaining = template.legendaryActionBudget;
  }

  // Condition duration decrement & save reminders
  c._expiredConditions = [];
  if (c.conditions && c.conditions.length > 0) {
    c.conditions = c.conditions.filter(cond => {
      if (cond.durationType === 'rounds') {
        cond.duration--;
        if (cond.duration <= 0) {
          c.rollLog.push({ label: 'Condition Expired', text: cond.name + ' has worn off', cssClass: '' });
          c._expiredConditions.push(cond);
          return false;
        }
        c.rollLog.push({ label: 'Condition', text: cond.name + ' - ' + cond.duration + ' round' + (cond.duration !== 1 ? 's' : '') + ' remaining', cssClass: '' });
      } else if (cond.durationType === 'save') {
        c.rollLog.push({ label: 'Save Needed', text: cond.name + ' - ' + cond.saveAbility.toUpperCase() + ' save DC ' + cond.saveDC, cssClass: '' });
      }
      return true;
    });
  }
}

function reverseTurnStartEffects(idx) {
  const c = getCombatant(idx);
  if (!c) return;
  // Re-increment round-based condition durations that were decremented on turn start
  if (c.conditions && c.conditions.length > 0) {
    c.conditions.forEach(function(cond) {
      if (cond.durationType === 'rounds') {
        cond.duration++;
      }
    });
  }
  // Restore conditions that expired this turn
  if (c._expiredConditions && c._expiredConditions.length > 0) {
    c._expiredConditions.forEach(function(cond) {
      cond.duration = 1; // was 0 after decrement, restore to 1
      if (!c.conditions) c.conditions = [];
      c.conditions.push(cond);
    });
    c._expiredConditions = [];
  }
}

function nextTurn() {
  const combat = getActiveCombat();
  if (!combat || combat.round < 1) return;

  // Collapse previous auto-expanded panel
  if (autoExpandedId) {
    const prev = combat.combatants.find(function(c) { return c.id === autoExpandedId; });
    if (prev) prev._expanded = false;
    autoExpandedId = null;
  }

  const startIdx = combat.turnIndex;
  let next = startIdx;
  let wrapped = false;

  do {
    next++;
    if (next >= combat.combatants.length) {
      next = 0;
      wrapped = true;
    }
    if (next === startIdx) break;
  } while (combat.combatants[next].dead);

  if (wrapped) combat.round++;

  combat.turnIndex = next;
  applyTurnStartEffects(next);

  // Auto-expand the new active combatant
  const active = combat.combatants[next];
  if (!active._expanded) {
    active._expanded = true;
    autoExpandedId = active.id;
  }

  setStatus('Round ' + combat.round + ' - ' + active.name + '\'s turn', 'success');
  saveCombat();
  render();
}

function prevTurn() {
  const combat = getActiveCombat();
  if (!combat || combat.round < 1) return;

  // Collapse previous auto-expanded panel
  if (autoExpandedId) {
    const prevAuto = combat.combatants.find(function(c) { return c.id === autoExpandedId; });
    if (prevAuto) prevAuto._expanded = false;
    autoExpandedId = null;
  }

  // Reverse turn-start effects on the current combatant before moving back
  const startIdx = combat.turnIndex;
  reverseTurnStartEffects(startIdx);

  let prev = startIdx;
  let wrapped = false;

  do {
    prev--;
    if (prev < 0) {
      prev = combat.combatants.length - 1;
      wrapped = true;
    }
    if (prev === startIdx) break;
  } while (combat.combatants[prev].dead);

  if (wrapped) combat.round = Math.max(1, combat.round - 1);

  combat.turnIndex = prev;

  // Auto-expand the new active combatant
  const active = combat.combatants[prev];
  if (!active._expanded) {
    active._expanded = true;
    autoExpandedId = active.id;
  }

  setStatus('Round ' + combat.round + ' - ' + active.name + '\'s turn', 'success');
  saveCombat();
  render();
}

function toggleReaction(idx) {
  const c = getCombatant(idx);
  if (!c) return;
  c.reactionUsed = !c.reactionUsed;
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Mid-Combat Editing ──
// ═══════════════════════════════════════════════════════════════

function editInit(idx, value) {
  const combat = getActiveCombat();
  const isCurrentTurn = (idx === combat.turnIndex);
  combat.combatants[idx].init = value === '' ? null : +value;

  if (isCurrentTurn && combat.round >= 1) {
    // Dropping init ends your turn: find the next combatant in current order before re-sorting
    let nextIdx = combat.turnIndex;
    do {
      nextIdx++;
      if (nextIdx >= combat.combatants.length) { nextIdx = 0; combat.round++; }
      if (nextIdx === combat.turnIndex) break;
    } while (combat.combatants[nextIdx].dead);
    const nextId = combat.combatants[nextIdx].id;
    applyTurnStartEffects(nextIdx);
    combat.combatants.sort((a, b) => (b.init ?? -Infinity) - (a.init ?? -Infinity));
    combat.turnIndex = combat.combatants.findIndex(c => c.id === nextId);
    if (combat.turnIndex < 0) combat.turnIndex = 0;
    setStatus('Round ' + combat.round + ' - ' + combat.combatants[combat.turnIndex].name + '\'s turn', 'success');
  } else {
    // Non-current combatant: re-sort, preserve current turn
    const currentId = combat.combatants[combat.turnIndex].id;
    combat.combatants.sort((a, b) => (b.init ?? -Infinity) - (a.init ?? -Infinity));
    combat.turnIndex = combat.combatants.findIndex(c => c.id === currentId);
    if (combat.turnIndex < 0) combat.turnIndex = 0;
  }

  saveCombat();
  render();
}

function killCombatant(idx) {
  const c = getCombatant(idx);
  if (!c) return;
  c.dead = true;
  if (c.type === 'monster') c.currentHp = 0;
  setStatus(c.name + ' is dead.', 'warning');
  saveCombat();
  render();
}

function reviveCombatant(idx) {
  const c = getCombatant(idx);
  if (!c) return;
  c.dead = false;
  if (c.type === 'monster' && (c.currentHp === undefined || c.currentHp <= 0)) c.currentHp = 1;
  setStatus(c.name + ' is back!', 'success');
  saveCombat();
  render();
}

function removeCombatant(idx) {
  const combat = getActiveCombat();
  const c = combat.combatants[idx];
  if (!confirm('Remove ' + c.name + ' from combat?')) return;

  if (idx < combat.turnIndex) {
    combat.turnIndex--;
  } else if (idx === combat.turnIndex && combat.turnIndex >= combat.combatants.length - 1) {
    combat.turnIndex = 0;
  }

  combat.combatants.splice(idx, 1);
  if (combat.combatants.length === 0) { endCombat(); return; }
  if (combat.turnIndex >= combat.combatants.length) combat.turnIndex = 0;

  saveCombat();
  render();
}

function endCombat() {
  const active = getActiveCombat();
  if (active && active.round >= 1) {
    if (!confirm('End combat? This cannot be undone.')) return;
  }
  state.combats = state.combats.filter(c => c.id !== activeCombatId);
  activeCombatId = null;
  pendingCombatEncounterId = null;
  saveCombat();
  setStatus('Combat ended.', 'warning');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── 5etools Importer ──
// ═══════════════════════════════════════════════════════════════

const SIZE_MAP = { F: 'Fine', D: 'Diminutive', T: 'Tiny', S: 'Small', M: 'Medium', L: 'Large', H: 'Huge', G: 'Gargantuan', C: 'Colossal', V: 'Varies' };

function strip5eToolsTags(text) {
  if (typeof text !== 'string') return String(text || '');
  let s = text;
  let safety = 20;
  while (s.indexOf('{@') !== -1 && safety-- > 0) {
    s = s.replace(/\{@([\w]+)\s*([^{}]*)\}/g, function(match, tag, content) {
      tag = tag.toLowerCase();
      if (tag === 'h') return 'Hit: ';
      if (tag === 'atkr' || tag === 'atk') {
        const ps = content.split(',').map(function(p) { return p.trim().toLowerCase(); });
        const lbl = [];
        if (ps.indexOf('mw') !== -1) lbl.push('Melee');
        if (ps.indexOf('rw') !== -1) lbl.push('Ranged');
        if (ps.indexOf('ms') !== -1) lbl.push('Melee');
        if (ps.indexOf('rs') !== -1) lbl.push('Ranged');
        const spell = ps.indexOf('ms') !== -1 || ps.indexOf('rs') !== -1;
        if (lbl.length === 0) return '';
        return lbl.filter(function(v, i, a) { return a.indexOf(v) === i; }).join(' or ') +
          (spell ? ' Spell' : ' Weapon') + ' Attack: ';
      }
      if (tag === 'hit') return '+' + content.trim();
      if (tag === 'dc') return 'DC ' + content.trim();
      if (tag === 'recharge') {
        const n = content.trim();
        return n ? '(Recharge ' + n + '-6)' : '(Recharge 6)';
      }
      if (tag === 'damage' || tag === 'dice') return content.split('|')[0].trim();
      if (tag === 'actsave') {
        const ab = content.trim().toLowerCase();
        return (ABILITY_NAMES[ab] || ab.charAt(0).toUpperCase() + ab.slice(1)) + ' saving throw';
      }
      if (tag === 'actsavefail') return 'Failure:';
      if (tag === 'actsavesuccess') return 'Success:';
      if (tag === 'actsavesuccessorfail') return 'Success or Failure:';
      // Reference tags: use display text (3rd segment) if present, otherwise first segment
      const parts = content.split('|');
      return (parts.length >= 3 ? parts[parts.length - 1] : parts[0]).trim();
    });
  }
  return s.trim();
}

function flattenEntries(entries) {
  if (!entries) return '';
  if (typeof entries === 'string') return strip5eToolsTags(entries);
  if (!Array.isArray(entries)) {
    if ((entries.type === 'item' || entries.type === 'itemSub') && entries.name) {
      return entries.name + '. ' + flattenEntries(entries.entry || entries.entries || []);
    }
    if (entries.entries) return flattenEntries(entries.entries);
    if (entries.type === 'list' && entries.items) {
      return entries.items.map(function(item) { return flattenEntries(item); }).join('\n');
    }
    if (entries.type === 'table') {
      let t = entries.caption ? entries.caption + ':\n' : '';
      if (entries.colLabels) t += entries.colLabels.join(' | ') + '\n';
      if (entries.rows) entries.rows.forEach(function(row) {
        t += row.map(function(cell) { return flattenEntries(cell); }).join(' | ') + '\n';
      });
      return strip5eToolsTags(t.trim());
    }
    if (typeof entries === 'object') return JSON.stringify(entries);
    return String(entries);
  }
  return entries.map(function(e) { return flattenEntries(e); }).filter(Boolean).join('\n');
}

function parse5eSize(sizeArr) {
  if (!sizeArr || !Array.isArray(sizeArr)) return 'Medium';
  return sizeArr.map(function(s) { return SIZE_MAP[s] || s; }).join('/');
}

function parse5eType(type) {
  if (!type) return '';
  if (typeof type === 'string') return type.charAt(0).toUpperCase() + type.slice(1);
  if (type.type) {
    const base = typeof type.type === 'string' ? type.type : '';
    return base.charAt(0).toUpperCase() + base.slice(1);
  }
  return '';
}

function parse5eAc(acArr) {
  if (!acArr || !Array.isArray(acArr) || acArr.length === 0) return { ac: 10, acNote: '' };
  const first = acArr[0];
  if (typeof first === 'number') return { ac: first, acNote: '' };
  if (first.special) return { ac: 10, acNote: strip5eToolsTags(first.special) };
  const ac = first.ac || 10;
  let note = '';
  if (first.from && Array.isArray(first.from)) {
    note = first.from.map(function(f) { return strip5eToolsTags(f); }).join(', ');
  }
  if (first.condition) note = (note ? note + ' ' : '') + strip5eToolsTags(first.condition);
  return { ac: ac, acNote: note };
}

function parse5eSpeed(speed) {
  if (!speed) return '30 ft.';
  if (typeof speed === 'number') return speed + ' ft.';
  if (typeof speed === 'string') return speed;
  const parts = [];
  const order = ['walk', 'burrow', 'climb', 'fly', 'swim'];
  order.forEach(function(mode) {
    const val = speed[mode];
    if (val === undefined || val === null || val === false || val === 0) return;
    let num;
    if (typeof val === 'number') num = val;
    else if (typeof val === 'object' && val.number) num = val.number;
    else if (val === true) num = null; // "equal to walking speed"
    else return;
    let str = '';
    if (mode === 'walk') str = (num || '?') + ' ft.';
    else str = mode + ' ' + (num || '?') + ' ft.';
    if (typeof val === 'object' && val.condition) str += ' ' + strip5eToolsTags(val.condition);
    else if (mode === 'fly' && speed.canHover) str += ' (hover)';
    parts.push(str);
  });
  // Alternate speeds
  if (speed.alternate) {
    Object.keys(speed.alternate).forEach(function(mode) {
      speed.alternate[mode].forEach(function(alt) {
        if (alt.number) {
          let str = mode === 'walk' ? alt.number + ' ft.' : mode + ' ' + alt.number + ' ft.';
          if (alt.condition) str += ' ' + strip5eToolsTags(alt.condition);
          parts.push(str);
        }
      });
    });
  }
  return parts.join(', ') || '0 ft.';
}

function parse5eSaves(saveObj) {
  if (!saveObj) return [];
  return Object.keys(saveObj).map(function(ab) {
    const val = saveObj[ab];
    const bonus = parseInt(String(val).replace('+', ''), 10);
    return { ability: ab.toLowerCase(), bonus: isNaN(bonus) ? 0 : bonus };
  });
}

function parse5eSkills(skillObj) {
  if (!skillObj) return [];
  const skills = [];
  Object.keys(skillObj).forEach(function(name) {
    if (name === 'other') return; // skip conditional skills
    const val = skillObj[name];
    const bonus = parseInt(String(val).replace('+', ''), 10);
    // Capitalize skill name properly
    const capName = name.replace(/\b\w/g, function(c) { return c.toUpperCase(); });
    skills.push({ name: capName, bonus: isNaN(bonus) ? 0 : bonus });
  });
  return skills;
}

function parse5eCr(cr) {
  if (!cr) return '';
  if (typeof cr === 'string') return cr;
  if (cr.cr) return cr.cr;
  return '';
}

function parse5eResist(arr) {
  if (!arr || !Array.isArray(arr)) return '';
  const parts = [];
  arr.forEach(function(entry) {
    if (typeof entry === 'string') {
      const clean = entry.indexOf('|') !== -1 ? entry.split('|')[0] : entry;
      parts.push(clean.charAt(0).toUpperCase() + clean.slice(1));
    } else if (entry.special) {
      parts.push(strip5eToolsTags(entry.special));
    } else {
      // Conditional: { resist/immune/vulnerable: [...], note: "..." }
      const key = entry.resist || entry.immune || entry.vulnerable || entry.conditionImmune || [];
      const types = key.map(function(t) {
        if (typeof t === 'string') {
          const clean = t.indexOf('|') !== -1 ? t.split('|')[0] : t;
          return clean.charAt(0).toUpperCase() + clean.slice(1);
        }
        return strip5eToolsTags(JSON.stringify(t));
      });
      let text = '';
      if (entry.preNote) text += strip5eToolsTags(entry.preNote) + ' ';
      text += types.join(', ');
      if (entry.note) text += ' ' + strip5eToolsTags(entry.note);
      parts.push(text.trim());
    }
  });
  return parts.join(', ');
}

function parse5eAlignment(align) {
  if (!align || !Array.isArray(align)) return '';
  const map = { L: 'Lawful', N: 'Neutral', NX: 'Neutral', NY: 'Neutral', C: 'Chaotic', G: 'Good', E: 'Evil', U: 'Unaligned', A: 'Any' };
  // Detect alignment ranges: if all entries are strings, check for axis patterns
  const allStrings = align.every(function(a) { return typeof a === 'string'; });
  if (allStrings) {
    const codes = align;
    const lawAxis = codes.filter(function(c) { return c === 'L' || c === 'NX' || c === 'C'; });
    const moralAxis = codes.filter(function(c) { return c === 'G' || c === 'NY' || c === 'E'; });
    // "Any alignment" patterns
    if (codes.indexOf('A') !== -1) return 'Any Alignment';
    if (codes.indexOf('U') !== -1) return 'Unaligned';
    // Full axis range (L+NX+C or G+NY+E) = "Any" on that axis
    const anyLaw = lawAxis.length === 3;
    const anyMoral = moralAxis.length === 3;
    if (anyLaw && anyMoral) return 'Any Alignment';
    if (anyLaw && moralAxis.length === 1) return 'Any ' + map[moralAxis[0]];
    if (anyMoral && lawAxis.length === 1) return map[lawAxis[0]] + ' Any';
    // Partial ranges (e.g. L+NX = "Lawful or Neutral")
    if (lawAxis.length > 1 || moralAxis.length > 1) {
      const lawPart = lawAxis.length > 0 ? lawAxis.map(function(c) { return map[c]; }).join(' or ') : '';
      const moralPart = moralAxis.length > 0 ? moralAxis.map(function(c) { return map[c]; }).join(' or ') : '';
      if (lawPart && moralPart) return lawPart + ' ' + moralPart;
      return lawPart || moralPart;
    }
  }
  // Standard case: simple concatenation
  const parts = [];
  align.forEach(function(a) {
    if (typeof a === 'string') parts.push(map[a] || a);
    else if (a.special) parts.push(strip5eToolsTags(a.special));
    else if (a.alignment) parts.push(a.alignment.map(function(c) { return map[c] || c; }).join(' '));
  });
  return parts.join(' ');
}

function profBonusFromCr(crStr) {
  if (!crStr) return 2;
  let cr;
  if (crStr.indexOf('/') !== -1) cr = 0;
  else cr = parseInt(crStr, 10);
  if (isNaN(cr) || cr <= 4) return 2;
  if (cr <= 8) return 3;
  if (cr <= 12) return 4;
  if (cr <= 16) return 5;
  if (cr <= 20) return 6;
  if (cr <= 24) return 7;
  if (cr <= 28) return 8;
  return 9;
}

function parse5eInitiative(init, dexScore, crStr) {
  const dexMod = Math.floor(((dexScore || 10) - 10) / 2);
  if (init === undefined || init === null) return { initBonus: dexMod, initAdvantage: false };
  if (typeof init === 'number') return { initBonus: init, initAdvantage: false };
  if (typeof init === 'object') {
    let bonus = dexMod;
    if (init.initiative !== undefined) bonus = init.initiative;
    else if (init.proficiency) bonus = dexMod + init.proficiency * profBonusFromCr(crStr);
    const adv = init.advantageMode === 'adv';
    return { initBonus: bonus, initAdvantage: adv };
  }
  return { initBonus: dexMod, initAdvantage: false };
}

function extractRechargeFromName(name) {
  let recharge = null;
  let usesMax = null;
  let cleanName = name;
  // {recharge N} or (Recharge N-6)
  const rechargeTag = cleanName.match(/\{@recharge\s*(\d*)}/i);
  if (rechargeTag) {
    recharge = rechargeTag[1] ? rechargeTag[1] + '-6' : '6';
    usesMax = 1;
    cleanName = cleanName.replace(rechargeTag[0], '').trim();
  }
  const rechargeParen = cleanName.match(/\(Recharge\s+(\d+)(?:-6)?\)/i);
  if (rechargeParen) {
    recharge = rechargeParen[1] + '-6';
    usesMax = 1;
    cleanName = cleanName.replace(rechargeParen[0], '').trim();
  }
  // (N/Day) or (1/Round)
  const usesMatch = cleanName.match(/\((\d+)\/Day\)/i);
  if (usesMatch) {
    usesMax = parseInt(usesMatch[1], 10);
    cleanName = cleanName.replace(usesMatch[0], '').trim();
  }
  const restMatch = cleanName.match(/\(Recharges after a (?:Short or )?Long Rest\)/i);
  if (restMatch) {
    usesMax = 1;
    cleanName = cleanName.replace(restMatch[0], '').trim();
  }
  return { cleanName: cleanName, recharge: recharge, usesMax: usesMax };
}

function parse5eActions(actionArr) {
  const attacks = [];
  const features = [];
  let multiattack = '';

  if (!actionArr || !Array.isArray(actionArr)) return { attacks: attacks, features: features, multiattack: multiattack };

  actionArr.forEach(function(action) {
    if (!action || !action.name) return;
    const rawName = action.name;
    const entryText = flattenEntries(action.entries || []);
    const rawEntryText = (action.entries || []).map(function(e) { return typeof e === 'string' ? e : flattenEntries(e); }).join(' ');

    // Multiattack detection
    if (rawName.toLowerCase().indexOf('multiattack') === 0) {
      multiattack = strip5eToolsTags(entryText);
      return;
    }

    // Attack detection: check raw text for attack tags
    const isAttack = rawEntryText.indexOf('{@atkr') !== -1 ||
                     rawEntryText.indexOf('{@atk ') !== -1 ||
                     rawEntryText.indexOf('{@hit') !== -1;

    if (isAttack) {
      // Parse attack
      const hitMatch = rawEntryText.match(/\{@hit\s+(\d+)\}/);
      const bonus = hitMatch ? parseInt(hitMatch[1], 10) : 0;

      // Extract name - strip parentheticals like "(Wolf Form Only)"
      let attackName = strip5eToolsTags(rawName);
      let attackNote = '';
      const parenMatch = attackName.match(/\s*\(([^)]+)\)\s*$/);
      if (parenMatch) {
        attackNote = parenMatch[1];
        attackName = attackName.replace(parenMatch[0], '').trim();
      }

      // Extract reach/range for note
      const reachMatch = entryText.match(/reach\s+\d+\s*ft\./i);
      const rangeMatch = entryText.match(/range\s+[\d/]+\s*ft\./i);
      if (reachMatch && rangeMatch) {
        attackNote = (attackNote ? attackNote + ', ' : '') + reachMatch[0] + ' or ' + rangeMatch[0];
      } else if (reachMatch) {
        attackNote = (attackNote ? attackNote + ', ' : '') + reachMatch[0];
      } else if (rangeMatch) {
        attackNote = (attackNote ? attackNote + ', ' : '') + rangeMatch[0];
      }

      // Extract damages
      const damages = [];
      const dmgPattern = /(\d+d\d+(?:\s*[+\-]\s*\d+)?)\)?\s*(\w+)\s*damage/gi;
      let dmgMatch;
      const strippedEntry = strip5eToolsTags(rawEntryText);
      while ((dmgMatch = dmgPattern.exec(strippedEntry)) !== null) {
        const dice = dmgMatch[1].replace(/\s/g, '');
        const type = dmgMatch[2].charAt(0).toUpperCase() + dmgMatch[2].slice(1);
        damages.push({ dice: dice, type: type, note: '' });
      }

      // If no damages found, try simpler extraction
      if (damages.length === 0) {
        const simpleDmg = strippedEntry.match(/(\d+)\s*\((\d+d\d+(?:\s*[+\-]\s*\d+)?)\)/);
        if (simpleDmg) {
          damages.push({ dice: simpleDmg[2].replace(/\s/g, ''), type: '', note: '' });
        }
      }

      // Use full stripped entry text as attack description
      const attackDesc = strippedEntry ? strippedEntry.replace(/\s+/g, ' ').trim() : '';

      attacks.push({ name: attackName, bonus: bonus, note: attackNote, desc: attackDesc, damages: damages });
    } else {
      // Non-attack action -> feature
      const extracted = extractRechargeFromName(strip5eToolsTags(rawName));
      features.push({
        name: extracted.cleanName,
        desc: strip5eToolsTags(entryText),
        recharge: extracted.recharge,
        usesMax: extracted.usesMax
      });
    }
  });

  return { attacks: attacks, features: features, multiattack: multiattack };
}

function parse5eLegendary(legArr) {
  if (!legArr || !Array.isArray(legArr)) return [];
  // Only merge continuations if the array uses "Action N:" naming (MCDM villain style)
  const usesActionPrefix = legArr.some(function(la) { return la.name && /^Action\s+\d+:/i.test(la.name); });
  const actions = [];
  legArr.forEach(function(la) {
    if (!la.name) return; // Skip header/intro text entries
    const costMatch = la.name.match(/\((?:Costs?\s+)?(\d+)\s+Actions?\)/i);
    const isNumberedAction = /^Action\s+\d+:/i.test(la.name);
    const desc = strip5eToolsTags(flattenEntries(la.entries || []));
    if (usesActionPrefix && !costMatch && !isNumberedAction && actions.length > 0) {
      // Continuation entry - merge into previous action (only in "Action N:" mode)
      const prev = actions[actions.length - 1];
      prev.desc += '\n\n' + strip5eToolsTags(la.name) + ': ' + desc;
    } else {
      const cost = costMatch ? parseInt(costMatch[1], 10) : 1;
      let name = strip5eToolsTags(la.name);
      if (costMatch) name = name.replace(costMatch[0], '').trim();
      actions.push({ name: name, cost: cost, desc: desc });
    }
  });
  return actions;
}

function parse5eSpellcasting(spellArr) {
  if (!spellArr || !Array.isArray(spellArr)) return [];
  const features = [];
  spellArr.forEach(function(sc) {
    const extracted = extractRechargeFromName(strip5eToolsTags(sc.name || 'Spellcasting'));
    let desc = '';
    if (sc.headerEntries) desc = flattenEntries(sc.headerEntries);
    // Add recharge spells
    if (sc.recharge) {
      Object.keys(sc.recharge).forEach(function(key) {
        desc += '\nRecharge ' + key + '-6: ' + sc.recharge[key].map(function(s) { return strip5eToolsTags(s); }).join(', ');
      });
    }
    // Add at-will spells
    if (sc.will) desc += '\nAt will: ' + sc.will.map(function(s) { return strip5eToolsTags(s); }).join(', ');
    // Add daily spells
    if (sc.daily) {
      Object.keys(sc.daily).forEach(function(key) {
        const uses = key.replace('e', '');
        desc += '\n' + uses + '/day: ' + sc.daily[key].map(function(s) { return strip5eToolsTags(s); }).join(', ');
      });
    }
    // Add spell slots
    if (sc.spells) {
      Object.keys(sc.spells).forEach(function(lvl) {
        const slot = sc.spells[lvl];
        const spellList = (slot.spells || []).map(function(s) { return strip5eToolsTags(s); }).join(', ');
        if (lvl === '0') desc += '\nCantrips: ' + spellList;
        else {
          const slots = slot.slots !== undefined ? ' (' + slot.slots + ' slot' + (slot.slots !== 1 ? 's' : '') + ')' : '';
          desc += '\nLevel ' + lvl + slots + ': ' + spellList;
        }
      });
    }
    features.push({
      name: extracted.cleanName,
      desc: desc.trim(),
      recharge: extracted.recharge,
      usesMax: extracted.usesMax
    });
  });
  return features;
}

function extractLegendaryResistances(traits) {
  if (!traits || !Array.isArray(traits)) return 0;
  for (let i = 0; i < traits.length; i++) {
    const t = traits[i];
    if (t.name && t.name.indexOf('Legendary Resistance') !== -1) {
      const m = t.name.match(/\((\d+)\/Day/i);
      if (m) return parseInt(m[1], 10);
      return 3; // Default
    }
  }
  return 0;
}

function import5etools(json) {
  // Detect single vs array
  let creatures;
  if (Array.isArray(json)) {
    creatures = json;
  } else if (json.monster && Array.isArray(json.monster)) {
    creatures = json.monster;
  } else if (json.name && (json.str !== undefined || json.ac !== undefined)) {
    creatures = [json];
  } else {
    return [];
  }

  return creatures.map(function(m) {
    if (!m || !m.name) return null;

    // Ability scores
    const abilities = {
      str: (typeof m.str === 'number' ? m.str : 10),
      dex: (typeof m.dex === 'number' ? m.dex : 10),
      con: (typeof m.con === 'number' ? m.con : 10),
      int: (typeof m.int === 'number' ? m.int : 10),
      wis: (typeof m.wis === 'number' ? m.wis : 10),
      cha: (typeof m.cha === 'number' ? m.cha : 10)
    };

    const crStr = parse5eCr(m.cr);
    const acData = parse5eAc(m.ac);
    const initData = parse5eInitiative(m.initiative, abilities.dex, crStr);

    // Parse actions -> attacks + features + multiattack
    const actionData = parse5eActions(m.action);

    // Start with traits as features
    const allFeatures = [];

    // Traits (passive features) - skip Legendary Resistance trait (extracted separately)
    if (m.trait && Array.isArray(m.trait)) {
      m.trait.forEach(function(t) {
        if (t.name && t.name.indexOf('Legendary Resistance') !== -1) return;
        const extracted = extractRechargeFromName(strip5eToolsTags(t.name || ''));
        allFeatures.push({
          name: extracted.cleanName,
          desc: strip5eToolsTags(flattenEntries(t.entries || [])),
          recharge: extracted.recharge,
          usesMax: extracted.usesMax
        });
      });
    }

    // Action-derived features
    actionData.features.forEach(function(f) { allFeatures.push(f); });

    // Bonus actions -> features
    if (m.bonus && Array.isArray(m.bonus)) {
      m.bonus.forEach(function(b) {
        if (!b.name) return;
        const extracted = extractRechargeFromName(strip5eToolsTags(b.name));
        allFeatures.push({
          name: extracted.cleanName + ' (Bonus Action)',
          desc: strip5eToolsTags(flattenEntries(b.entries || [])),
          recharge: extracted.recharge,
          usesMax: extracted.usesMax
        });
      });
    }

    // Reactions -> features
    if (m.reaction && Array.isArray(m.reaction)) {
      m.reaction.forEach(function(r) {
        if (!r.name) return;
        const extracted = extractRechargeFromName(strip5eToolsTags(r.name));
        allFeatures.push({
          name: extracted.cleanName + ' (Reaction)',
          desc: strip5eToolsTags(flattenEntries(r.entries || [])),
          recharge: extracted.recharge,
          usesMax: extracted.usesMax
        });
      });
    }

    // Spellcasting -> features
    parse5eSpellcasting(m.spellcasting).forEach(function(f) { allFeatures.push(f); });

    // Mythic actions -> features
    if (m.mythic && Array.isArray(m.mythic)) {
      m.mythic.forEach(function(my) {
        if (!my.name) return;
        const extracted = extractRechargeFromName(strip5eToolsTags(my.name));
        allFeatures.push({
          name: extracted.cleanName + ' (Mythic)',
          desc: strip5eToolsTags(flattenEntries(my.entries || [])),
          recharge: extracted.recharge,
          usesMax: extracted.usesMax
        });
      });
    }

    // HP
    let hpMax = 1;
    let hpFormula = '';
    if (m.hp) {
      if (m.hp.average) hpMax = m.hp.average;
      if (m.hp.formula) hpFormula = m.hp.formula;
      if (m.hp.special) { hpFormula = m.hp.special; if (!m.hp.average) hpMax = 0; }
    }

    return {
      id: uuid(),
      name: m.name,
      size: parse5eSize(m.size),
      type: parse5eType(m.type),
      alignment: parse5eAlignment(m.alignment),
      ac: acData.ac,
      acNote: acData.acNote,
      hpMax: hpMax,
      hpFormula: hpFormula,
      speed: parse5eSpeed(m.speed),
      cr: crStr,
      abilities: abilities,
      savingThrows: parse5eSaves(m.save),
      skills: parse5eSkills(m.skill),
      damageResistances: parse5eResist(m.resist),
      damageImmunities: parse5eResist(m.immune),
      damageVulnerabilities: parse5eResist(m.vulnerable),
      conditionImmunities: parse5eResist(m.conditionImmune),
      senses: m.senses ? strip5eToolsTags(m.senses.join(', ')) : '',
      passivePerception: typeof m.passive === 'number' ? m.passive : null,
      languages: m.languages ? m.languages.join(', ') : '',
      tactics: '',
      initBonus: initData.initBonus,
      initAdvantage: initData.initAdvantage,
      critRange: 20,
      attacks: actionData.attacks,
      multiattack: actionData.multiattack,
      features: allFeatures,
      legendaryActionBudget: m.legendaryActions || (m.legendary && m.legendary.length > 0 ? 3 : 0),
      legendaryActions: parse5eLegendary(m.legendary),
      legendaryResistances: extractLegendaryResistances(m.trait),
      lairActions: [],
      source: (m.source || '') + (m.page ? ' p' + m.page : ''),
      gear: '',
      playerDescription: '',
      dmDescription: ''
    };
  }).filter(Boolean);
}

function detect5eToolsFormat(json) {
  // Multi-monster wrapper
  if (json.monster && Array.isArray(json.monster)) return true;
  // Single creature: has ability scores + ac as array (5etools signature)
  if (json.name && json.str !== undefined && Array.isArray(json.ac)) return true;
  // Single creature: has source field (5etools always has this)
  if (json.name && json.source && (json.str !== undefined || json.dex !== undefined)) return true;
  return false;
}

// ═══════════════════════════════════════════════════════════════
// ── Import / Export ──
// ═══════════════════════════════════════════════════════════════

function downloadBlob(blob, filename) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

async function exportData() {
  try {
    const payload = {
      format: 'encounter-manager',
      version: 1,
      exported: new Date().toISOString(),
      templates: state.templates,
      encounters: state.encounters,
      parties: state.parties,
      combats: state.combats,
      preferences: state.preferences
    };
    const json = JSON.stringify(payload);
    const compressed = await compress(json);
    const header = '[SquishText] To decode, base64-decode the string below then inflate (deflate-raw). Or paste at https://promptferret.github.io/SquishText/\n';
    downloadBlob(new Blob([header + compressed], { type: 'text/plain;charset=utf-8' }), 'encounter-backup-' + new Date().toISOString().slice(0, 10) + '.squishtext');
    setStatus('Backup exported!', 'success');
  } catch (e) {
    console.error('Export failed:', e);
    setStatus('Export failed: ' + e.message, 'error');
  }
}

function showImportDialog() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.squishtext';
  input.onchange = async function() {
    if (!input.files.length) return;
    try {
      const text = await input.files[0].text();
      const decompressed = await decompress(text);
      const data = JSON.parse(decompressed);
      if (!data.templates && !data.encounters) throw new Error('Invalid backup format');
      const existingIds = new Set();
      function mergeArray(existing, incoming) {
        existing.forEach(item => existingIds.add(item.id));
        let added = 0;
        (incoming || []).forEach(item => {
          if (!existingIds.has(item.id)) { existing.push(item); added++; }
        });
        existingIds.clear();
        return added;
      }
      let added = 0;
      added += mergeArray(state.templates, data.templates);
      added += mergeArray(state.encounters, data.encounters);
      added += mergeArray(state.parties, data.parties);
      added += mergeArray(state.combats, data.combats);
      if (data.preferences) {
        state.preferences = Object.assign(state.preferences || {}, data.preferences);
      }
      activeCombatId = null;
      // Restore active combat ID from imported preferences if valid
      const restoredCombatId = state.preferences && state.preferences.activeCombatId;
      if (restoredCombatId && state.combats.find(function(c) { return c.id === restoredCombatId; })) {
        activeCombatId = restoredCombatId;
      }
      save();
      setStatus('Backup loaded! ' + added + ' new item' + (added !== 1 ? 's' : '') + ' added, duplicates skipped.', 'success');
      const restoredView = state.preferences && state.preferences.view;
      if (restoredView && ['templates', 'parties', 'encounters', 'combat'].includes(restoredView)) {
        switchView(restoredView);
      } else {
        render();
      }
      updateStorageInfo();
    } catch (e) {
      console.error('Import failed:', e);
      setStatus('Import failed: ' + e.message, 'error');
    }
  };
  input.click();
}

// ── Monster Export Formatters ──

function wrapCanvasText(ctx, text, maxWidth, font) {
  ctx.font = font;
  const words = text.split(/\s+/);
  const lines = [];
  let current = '';
  for (let i = 0; i < words.length; i++) {
    const test = current ? current + ' ' + words[i] : words[i];
    if (ctx.measureText(test).width > maxWidth - 2 && current) {
      lines.push(current);
      current = words[i];
    } else {
      current = test;
    }
  }
  if (current) lines.push(current);
  return lines.length > 0 ? lines : [''];
}

function templateToCanvas(t) {
  const W = 400;
  const PAD = 16;
  const CW = W - PAD * 2;
  const BG = '#FDF1DC';
  const RED = '#58180D';
  const BLACK = '#1A1A1A';
  const LINE_H = 14;
  const BODY_FONT = '10px Georgia, "Times New Roman", serif';
  const BOLD_FONT = 'bold 10px Georgia, "Times New Roman", serif';
  const ITALIC_FONT = 'italic 10px Georgia, "Times New Roman", serif';
  const HEADER_FONT = 'bold 13px Georgia, "Times New Roman", serif';
  const TABLE_FONT = '9px Georgia, "Times New Roman", serif';
  const TABLE_BOLD = 'bold 9px Georgia, "Times New Roman", serif';

  const canvas = document.createElement('canvas');
  canvas.width = W;
  canvas.height = 4000;
  const ctx = canvas.getContext('2d');

  // Fill background
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, 4000);

  let y = 0;

  // Draw red divider
  function divider() {
    y += 6;
    ctx.fillStyle = RED;
    ctx.fillRect(PAD - 2, y, CW + 4, 2);
    y += 8;
  }

  // Draw bold label + normal value, wrapping if needed. Returns new y.
  function labelLine(label, value) {
    ctx.font = BOLD_FONT;
    ctx.fillStyle = BLACK;
    const labelW = ctx.measureText(label + ' ').width;
    ctx.font = BODY_FONT;
    const valueW = ctx.measureText(value).width;
    if (labelW + valueW <= CW) {
      y += LINE_H;
      ctx.font = BOLD_FONT;
      ctx.fillText(label, PAD, y);
      ctx.font = BODY_FONT;
      ctx.fillText(' ' + value, PAD + labelW, y);
    } else {
      // Wrap: first line gets label + partial value, rest is full width
      const allWords = value.split(/\s+/);
      let firstVal = '';
      let wi = 0;
      ctx.font = BODY_FONT;
      while (wi < allWords.length) {
        const test = firstVal ? firstVal + ' ' + allWords[wi] : allWords[wi];
        if (ctx.measureText(test).width > CW - labelW - 2 && firstVal) break;
        firstVal = test;
        wi++;
      }
      y += LINE_H;
      ctx.font = BOLD_FONT;
      ctx.fillText(label, PAD, y);
      ctx.font = BODY_FONT;
      ctx.fillText(' ' + firstVal, PAD + labelW, y);
      const rest = allWords.slice(wi).join(' ');
      if (rest) {
        const wrapped = wrapCanvasText(ctx, rest, CW, BODY_FONT);
        for (let i = 0; i < wrapped.length; i++) {
          y += LINE_H;
          ctx.fillText(wrapped[i], PAD, y);
        }
      }
    }
  }

  // Draw feature: bold name + wrapped description
  function featureBlock(name, desc) {
    ctx.font = BOLD_FONT;
    ctx.fillStyle = BLACK;
    const nameW = ctx.measureText(name + ' ').width;
    ctx.font = BODY_FONT;
    const descWords = (desc || '').split(/\s+/).filter(function(w) { return w; });
    if (descWords.length === 0) {
      y += LINE_H;
      ctx.font = BOLD_FONT;
      ctx.fillText(name, PAD, y);
      return;
    }
    // First line: bold name + start of desc
    let firstPart = '';
    let wi = 0;
    ctx.font = BODY_FONT;
    while (wi < descWords.length) {
      const test = firstPart ? firstPart + ' ' + descWords[wi] : descWords[wi];
      if (ctx.measureText(test).width > CW - nameW - 2 && firstPart) break;
      firstPart = test;
      wi++;
    }
    y += LINE_H;
    ctx.font = BOLD_FONT;
    ctx.fillText(name, PAD, y);
    ctx.font = BODY_FONT;
    ctx.fillText(' ' + firstPart, PAD + nameW, y);
    const rest = descWords.slice(wi).join(' ');
    if (rest) {
      const wrapped = wrapCanvasText(ctx, rest, CW, BODY_FONT);
      for (let i = 0; i < wrapped.length; i++) {
        y += LINE_H;
        ctx.fillText(wrapped[i], PAD, y);
      }
    }
  }

  // Draw section header (e.g., "Actions")
  function sectionHeader(text) {
    y += 4;
    ctx.font = HEADER_FONT;
    ctx.fillStyle = RED;
    ctx.fillText(text, PAD, y + LINE_H);
    y += LINE_H + 2;
    ctx.fillStyle = BLACK;
  }

  // ── 1. Name header bar ──
  ctx.font = 'bold 18px Georgia, "Times New Roman", serif';
  const nameH = 30;
  ctx.fillStyle = RED;
  ctx.fillRect(0, 0, W, nameH);
  ctx.fillStyle = '#FFFFFF';
  ctx.fillText(t.name || 'Unnamed', PAD, 21);
  y = nameH;

  // Subheader: size type, alignment
  const subParts = [];
  if (t.size) subParts.push(t.size);
  if (t.type) subParts.push(t.type);
  let subLine = subParts.join(' ');
  if (t.alignment) subLine += (subLine ? ', ' : '') + t.alignment;
  if (subLine) {
    y += 14;
    ctx.font = ITALIC_FONT;
    ctx.fillStyle = BLACK;
    ctx.fillText(subLine, PAD, y);
    y += 2;
  }

  // ── 2. AC, HP, Speed ──
  divider();
  labelLine('Armor Class', t.ac + (t.acNote ? ' (' + t.acNote + ')' : ''));
  labelLine('Hit Points', t.hpMax + (t.hpFormula ? ' (' + t.hpFormula + ')' : ''));
  if (t.speed) labelLine('Speed', t.speed);

  // ── 3. Ability score table ──
  divider();
  const colW = CW / 6;
  // Headers
  y += 12;
  ctx.font = TABLE_BOLD;
  ctx.fillStyle = RED;
  ABILITIES.forEach(function(ab, i) {
    const label = ab.toUpperCase();
    const lw = ctx.measureText(label).width;
    ctx.fillText(label, PAD + i * colW + (colW - lw) / 2, y);
  });
  // Values
  y += 14;
  ctx.font = TABLE_FONT;
  ctx.fillStyle = BLACK;
  ABILITIES.forEach(function(ab, i) {
    const score = t.abilities[ab];
    const text = score + ' (' + modStr(score) + ')';
    const tw = ctx.measureText(text).width;
    ctx.fillText(text, PAD + i * colW + (colW - tw) / 2, y);
  });

  // ── 4. Properties ──
  divider();
  if (t.savingThrows && t.savingThrows.length > 0) {
    labelLine('Saving Throws', t.savingThrows.map(function(st) {
      return st.ability.charAt(0).toUpperCase() + st.ability.slice(1) + ' ' + (st.bonus >= 0 ? '+' : '') + st.bonus;
    }).join(', '));
  }
  if (t.skills && t.skills.length > 0) {
    labelLine('Skills', t.skills.map(function(sk) {
      return sk.name + ' ' + (sk.bonus >= 0 ? '+' : '') + sk.bonus;
    }).join(', '));
  }
  if (t.damageResistances) labelLine('Damage Resistances', t.damageResistances);
  if (t.damageImmunities) labelLine('Damage Immunities', t.damageImmunities);
  if (t.damageVulnerabilities) labelLine('Damage Vulnerabilities', t.damageVulnerabilities);
  if (t.conditionImmunities) labelLine('Condition Immunities', t.conditionImmunities);
  const pp = getPassivePerception(t);
  let sensesVal = t.senses || '';
  if (sensesVal && sensesVal.toLowerCase().indexOf('passive perception') === -1) {
    sensesVal += ', passive Perception ' + pp;
  } else if (!sensesVal) {
    sensesVal = 'passive Perception ' + pp;
  }
  labelLine('Senses', sensesVal);
  if (t.languages) labelLine('Languages', t.languages);
  if (t.cr) labelLine('Challenge', t.cr);
  if (t.gear) labelLine('Gear', t.gear);
  if (t.source) labelLine('Source', t.source);

  // ── 5. Features ──
  // Categorize
  const regFeats = [];
  const rxnFeats = [];
  const baFeats = [];
  (t.features || []).forEach(function(f) {
    if (f.name && f.name.indexOf('(Reaction)') !== -1) rxnFeats.push(f);
    else if (f.name && f.name.indexOf('(Bonus Action)') !== -1) baFeats.push(f);
    else regFeats.push(f);
  });
  // Synthesize LR
  if (t.legendaryResistances > 0 && !regFeats.some(function(f) { return f.name && f.name.indexOf('Legendary Resistance') !== -1; })) {
    regFeats.unshift({
      name: 'Legendary Resistance (' + t.legendaryResistances + '/Day)',
      desc: 'If ' + (t.name || 'the creature') + ' fails a saving throw, it can choose to succeed instead.'
    });
  }

  if (regFeats.length > 0) {
    divider();
    regFeats.forEach(function(f) {
      let name = f.name || 'Unnamed';
      if (f.recharge) name += ' (Recharge ' + f.recharge + ')';
      else if (f.usesMax && f.usesMax > 0 && name.indexOf('/Day') === -1) name += ' (' + f.usesMax + '/Day)';
      featureBlock(name + '.', f.desc);
      y += 4;
    });
  }

  // ── 6. Actions ──
  const hasActions = t.multiattack || (t.attacks && t.attacks.length > 0);
  if (hasActions) {
    divider();
    sectionHeader('Actions');
    if (t.multiattack) {
      featureBlock('Multiattack.', t.multiattack);
      y += 4;
    }
    (t.attacks || []).forEach(function(atk) {
      let desc = '';
      if (atk.bonus !== undefined && atk.bonus !== null) {
        desc += (atk.bonus >= 0 ? '+' : '') + atk.bonus + ' to hit';
        if (atk.note) desc += ', ' + atk.note;
        if (!desc.endsWith('.')) desc += '.';
      }
      if (atk.damages && atk.damages.length > 0) {
        const parts = atk.damages.map(function(d) {
          let p = d.dice + ' ' + d.type;
          if (d.note) p += ' (' + d.note + ')';
          return p;
        });
        desc += ' Hit: ' + parts.join(' plus ') + ' damage.';
      }
      featureBlock(atk.name + '.', desc);
      if (atk.desc) {
        const atkDescLines = wrapCanvasText(ctx, atk.desc, CW, BODY_FONT);
        ctx.font = BODY_FONT;
        ctx.fillStyle = BLACK;
        atkDescLines.forEach(function(line) {
          y += LINE_H;
          ctx.fillText(line, PAD, y);
        });
      }
      y += 4;
    });
  }

  // ── 7. Bonus Actions ──
  if (baFeats.length > 0) {
    divider();
    sectionHeader('Bonus Actions');
    baFeats.forEach(function(f) {
      let name = (f.name || '').replace(/\s*\(Bonus Action\)/, '');
      if (f.recharge) name += ' (Recharge ' + f.recharge + ')';
      else if (f.usesMax && f.usesMax > 0) name += ' (' + f.usesMax + '/Day)';
      featureBlock(name + '.', f.desc);
      y += 4;
    });
  }

  // ── 8. Reactions ──
  if (rxnFeats.length > 0) {
    divider();
    sectionHeader('Reactions');
    rxnFeats.forEach(function(f) {
      let name = (f.name || '').replace(/\s*\(Reaction\)/, '');
      if (f.recharge) name += ' (Recharge ' + f.recharge + ')';
      else if (f.usesMax && f.usesMax > 0) name += ' (' + f.usesMax + '/Day)';
      featureBlock(name + '.', f.desc);
      y += 4;
    });
  }

  // ── 9. Legendary Actions ──
  if (t.legendaryActionBudget > 0 && t.legendaryActions && t.legendaryActions.length > 0) {
    divider();
    sectionHeader('Legendary Actions');
    // Intro text
    const introText = (t.name || 'The creature') + ' can take ' + t.legendaryActionBudget +
      ' legendary action' + (t.legendaryActionBudget !== 1 ? 's' : '') +
      ', choosing from the options below. Only one legendary action option can be used at a time and only at the end of another creature\'s turn. ' +
      (t.name || 'The creature') + ' regains spent legendary actions at the start of its turn.';
    const introLines = wrapCanvasText(ctx, introText, CW, ITALIC_FONT);
    ctx.font = ITALIC_FONT;
    ctx.fillStyle = BLACK;
    introLines.forEach(function(line) {
      y += LINE_H;
      ctx.fillText(line, PAD, y);
    });
    y += 6;
    t.legendaryActions.forEach(function(la) {
      let name = la.name || 'Unnamed';
      if (la.cost > 1) name += ' (Costs ' + la.cost + ' Actions)';
      featureBlock(name + '.', la.desc);
      y += 4;
    });
  }

  // ── 10. Lair Actions ──
  if (t.lairActions && t.lairActions.length > 0) {
    divider();
    sectionHeader('Lair Actions');
    const lairIntro = 'On initiative count 20 (losing initiative ties), ' +
      (t.name || 'the creature') + ' can take a lair action to cause one of the following effects:';
    const lairIntroLines = wrapCanvasText(ctx, lairIntro, CW, ITALIC_FONT);
    ctx.font = ITALIC_FONT;
    ctx.fillStyle = BLACK;
    lairIntroLines.forEach(function(line) {
      y += LINE_H;
      ctx.fillText(line, PAD, y);
    });
    y += 6;
    t.lairActions.forEach(function(la) {
      featureBlock((la.name || 'Unnamed') + '.', la.desc);
      y += 4;
    });
  }

  // ── Bottom border ──
  y += 8;
  ctx.fillStyle = RED;
  ctx.fillRect(0, y, W, 3);
  y += 3;

  // Crop to actual height
  const finalCanvas = document.createElement('canvas');
  finalCanvas.width = W;
  finalCanvas.height = y;
  const fctx = finalCanvas.getContext('2d');
  fctx.drawImage(canvas, 0, 0, W, y, 0, 0, W, y);
  return finalCanvas;
}

function templateToMarkdown(t) {
  const lines = [];

  // Header
  lines.push('# ' + (t.name || 'Unnamed'));
  const subParts = [];
  if (t.size) subParts.push(t.size);
  if (t.type) subParts.push(t.type);
  const sub = subParts.join(' ');
  if (sub || t.alignment) {
    lines.push('*' + sub + (t.alignment ? ', ' + t.alignment : '') + '*');
  }
  lines.push('');
  lines.push('---');
  lines.push('');

  // Core stats
  lines.push('**Armor Class** ' + t.ac + (t.acNote ? ' (' + t.acNote + ')' : ''));
  lines.push('**Hit Points** ' + t.hpMax + (t.hpFormula ? ' (' + t.hpFormula + ')' : ''));
  if (t.speed) lines.push('**Speed** ' + t.speed);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Ability score table
  lines.push('| STR | DEX | CON | INT | WIS | CHA |');
  lines.push('|:---:|:---:|:---:|:---:|:---:|:---:|');
  lines.push('| ' + ABILITIES.map(function(ab) {
    return t.abilities[ab] + ' (' + modStr(t.abilities[ab]) + ')';
  }).join(' | ') + ' |');
  lines.push('');
  lines.push('---');
  lines.push('');

  // Properties (only include non-empty)
  if (t.savingThrows && t.savingThrows.length > 0) {
    lines.push('**Saving Throws** ' + t.savingThrows.map(function(st) {
      const label = st.ability.charAt(0).toUpperCase() + st.ability.slice(1);
      return label + ' ' + (st.bonus >= 0 ? '+' : '') + st.bonus;
    }).join(', '));
  }
  if (t.skills && t.skills.length > 0) {
    lines.push('**Skills** ' + t.skills.map(function(sk) {
      return sk.name + ' ' + (sk.bonus >= 0 ? '+' : '') + sk.bonus;
    }).join(', '));
  }
  if (t.damageResistances) lines.push('**Damage Resistances** ' + t.damageResistances);
  if (t.damageImmunities) lines.push('**Damage Immunities** ' + t.damageImmunities);
  if (t.damageVulnerabilities) lines.push('**Damage Vulnerabilities** ' + t.damageVulnerabilities);
  if (t.conditionImmunities) lines.push('**Condition Immunities** ' + t.conditionImmunities);

  // Senses (append passive perception if not already present)
  const pp = getPassivePerception(t);
  let sensesLine = t.senses || '';
  if (sensesLine && sensesLine.toLowerCase().indexOf('passive perception') === -1) {
    sensesLine += ', passive Perception ' + pp;
  } else if (!sensesLine) {
    sensesLine = 'passive Perception ' + pp;
  }
  lines.push('**Senses** ' + sensesLine);

  if (t.languages) lines.push('**Languages** ' + t.languages);
  if (t.cr) lines.push('**Challenge** ' + t.cr);
  if (t.gear) lines.push('**Gear** ' + t.gear);
  if (t.source) lines.push('**Source** ' + t.source);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Categorize features
  const regularFeatures = [];
  const reactions = [];
  const bonusActions = [];
  (t.features || []).forEach(function(f) {
    if (f.name && f.name.indexOf('(Reaction)') !== -1) reactions.push(f);
    else if (f.name && f.name.indexOf('(Bonus Action)') !== -1) bonusActions.push(f);
    else regularFeatures.push(f);
  });

  // Synthesize Legendary Resistance as a feature if needed
  if (t.legendaryResistances > 0) {
    const hasLR = regularFeatures.some(function(f) { return f.name && f.name.indexOf('Legendary Resistance') !== -1; });
    if (!hasLR) {
      regularFeatures.unshift({
        name: 'Legendary Resistance (' + t.legendaryResistances + '/Day)',
        desc: 'If ' + (t.name || 'the creature') + ' fails a saving throw, it can choose to succeed instead.',
        recharge: null, usesMax: null
      });
    }
  }

  // Helper for feature line formatting
  function featureLine(f, stripAnnotation) {
    let name = f.name || 'Unnamed';
    if (stripAnnotation) name = name.replace(/\s*\(Reaction\)/, '').replace(/\s*\(Bonus Action\)/, '');
    let line = '**' + name;
    if (f.recharge) {
      line += ' (Recharge ' + f.recharge + ')';
    } else if (f.usesMax && f.usesMax > 0) {
      line += ' (' + f.usesMax + '/Day)';
    }
    line += '.** ' + (f.desc || '');
    return line;
  }

  // Regular features
  regularFeatures.forEach(function(f) {
    lines.push(featureLine(f, false));
    lines.push('');
  });

  // Actions
  const hasActions = t.multiattack || (t.attacks && t.attacks.length > 0);
  if (hasActions) {
    lines.push('### Actions');
    lines.push('');
    if (t.multiattack) {
      lines.push('**Multiattack.** ' + t.multiattack);
      lines.push('');
    }
    (t.attacks || []).forEach(function(atk) {
      let line = '**' + atk.name + '.** ';
      if (atk.bonus !== undefined && atk.bonus !== null) {
        line += (atk.bonus >= 0 ? '+' : '') + atk.bonus + ' to hit';
        if (atk.note) line += ', ' + atk.note;
        if (!line.endsWith('.')) line += '.';
      }
      if (atk.damages && atk.damages.length > 0) {
        const parts = atk.damages.map(function(d) {
          let part = d.dice + ' ' + d.type;
          if (d.note) part += ' (' + d.note + ')';
          return part;
        });
        line += ' *Hit:* ' + parts.join(' plus ') + ' damage.';
      }
      lines.push(line);
      if (atk.desc) lines.push(atk.desc);
      lines.push('');
    });
  }

  // Bonus Actions
  if (bonusActions.length > 0) {
    lines.push('### Bonus Actions');
    lines.push('');
    bonusActions.forEach(function(f) {
      lines.push(featureLine(f, true));
      lines.push('');
    });
  }

  // Reactions
  if (reactions.length > 0) {
    lines.push('### Reactions');
    lines.push('');
    reactions.forEach(function(f) {
      lines.push(featureLine(f, true));
      lines.push('');
    });
  }

  // Legendary Actions
  if (t.legendaryActionBudget > 0 && t.legendaryActions && t.legendaryActions.length > 0) {
    lines.push('### Legendary Actions');
    lines.push('');
    lines.push((t.name || 'The creature') + ' can take ' + t.legendaryActionBudget +
      ' legendary action' + (t.legendaryActionBudget !== 1 ? 's' : '') +
      ', choosing from the options below. Only one legendary action option can be used at a time and only at the end of another creature\'s turn. ' +
      (t.name || 'The creature') + ' regains spent legendary actions at the start of its turn.');
    lines.push('');
    t.legendaryActions.forEach(function(la) {
      let line = '**' + la.name;
      if (la.cost > 1) line += ' (Costs ' + la.cost + ' Actions)';
      line += '.** ' + (la.desc || '');
      lines.push(line);
      lines.push('');
    });
  }

  // Lair Actions
  if (t.lairActions && t.lairActions.length > 0) {
    lines.push('### Lair Actions');
    lines.push('');
    lines.push('On initiative count 20 (losing initiative ties), ' +
      (t.name || 'the creature') + ' can take a lair action to cause one of the following effects:');
    lines.push('');
    t.lairActions.forEach(function(la) {
      lines.push('**' + la.name + '.** ' + (la.desc || ''));
      lines.push('');
    });
  }

  // Descriptions (if present)
  if (t.tactics || t.playerDescription || t.dmDescription) {
    lines.push('---');
    lines.push('');
    if (t.playerDescription) {
      lines.push('**Description.** ' + t.playerDescription);
      lines.push('');
    }
    if (t.dmDescription) {
      lines.push('**DM Notes.** ' + t.dmDescription);
      lines.push('');
    }
    if (t.tactics) {
      lines.push('**Tactics.** ' + t.tactics);
      lines.push('');
    }
  }

  return lines.join('\n').replace(/\n{3,}/g, '\n\n').trim() + '\n';
}

// ── Monster Import / Export ──

function exportMonster(id) {
  const t = state.templates.find(t => t.id === id);
  if (!t) { setStatus('Monster not found.', 'error'); return; }
  _exportTargetId = id;
  showExportMonsterModal(t);
}

function showExportMonsterModal(template) {
  const bodyHtml =
    '<div class="modal-toggle-group">' +
    '<button id="exportModeEM" class="active" onclick="switchExportMode(\'em\')">EncounterManager</button>' +
    '<button id="exportModeJSON" onclick="switchExportMode(\'json\')">JSON</button>' +
    '<button id="exportModeMD" onclick="switchExportMode(\'md\')">Markdown</button>' +
    '<button id="exportModeImage" onclick="switchExportMode(\'image\')">Image</button>' +
    '</div>' +
    '<p id="exportDesc" class="text-muted-sm" style="margin-bottom:0.75rem">Compressed .squishtext format. Importable by EncounterManager.</p>' +
    '<div class="flex-row-end">' +
    '<button class="btn-sm" onclick="document.getElementById(\'exportModal\').remove()">Cancel</button>' +
    '<button class="btn-sm btn-action" onclick="doExportMonster()">Download</button>' +
    '</div>';
  createModal('exportModal', 'Export: ' + esc(template.name), bodyHtml, { wide: true });
}

function switchExportMode(mode) {
  const modes = { em: 'exportModeEM', json: 'exportModeJSON', md: 'exportModeMD', image: 'exportModeImage' };
  Object.keys(modes).forEach(function(key) {
    const el = document.getElementById(modes[key]);
    if (el) el.className = key === mode ? 'active' : '';
  });
  const desc = document.getElementById('exportDesc');
  if (desc) {
    const descriptions = {
      em: 'Compressed .squishtext format. Importable by EncounterManager.',
      json: 'Uncompressed JSON. Human-readable and importable.',
      md: 'Formatted D&D stat block as plain text.',
      image: 'Canvas-rendered stat block as PNG image.'
    };
    desc.textContent = descriptions[mode] || '';
  }
}

async function doExportMonster() {
  const t = state.templates.find(t => t.id === _exportTargetId);
  if (!t) { setStatus('Monster not found.', 'error'); return; }
  // Build filename: {name} - CR {cr} ({source}).{ext}, fallback to just {name}
  let exportName = t.name || 'monster';
  if (t.cr && t.source) {
    exportName += ' - CR ' + t.cr + ' (' + t.source + ')';
  } else if (t.cr) {
    exportName += ' - CR ' + t.cr;
  } else if (t.source) {
    exportName += ' - ' + t.source;
  }
  const safeName = exportName.replace(/[\/\\:*?"<>|]/g, '-').replace(/-{2,}/g, '-');

  // Determine active mode
  let mode = 'em';
  if (document.getElementById('exportModeJSON') && document.getElementById('exportModeJSON').className === 'active') mode = 'json';
  else if (document.getElementById('exportModeMD') && document.getElementById('exportModeMD').className === 'active') mode = 'md';
  else if (document.getElementById('exportModeImage') && document.getElementById('exportModeImage').className === 'active') mode = 'image';

  try {
    const envelope = { format: 'encounter-manager', version: 1, exported: new Date().toISOString(), templates: [t] };

    if (mode === 'em') {
      const compressed = await compress(JSON.stringify(envelope));
      const header = '[SquishText] To decode, base64-decode the string below then inflate (deflate-raw). Or paste at https://promptferret.github.io/SquishText/\n';
      downloadBlob(new Blob([header + compressed], { type: 'text/plain;charset=utf-8' }), safeName + '.squishtext');
    } else if (mode === 'json') {
      downloadBlob(new Blob([JSON.stringify(envelope, null, 2)], { type: 'application/json;charset=utf-8' }), safeName + '.json');
    } else if (mode === 'md') {
      if (typeof templateToMarkdown !== 'function') { setStatus('Markdown export not yet available.', 'warning'); return; }
      downloadBlob(new Blob([templateToMarkdown(t)], { type: 'text/markdown;charset=utf-8' }), safeName + '.md');
    } else if (mode === 'image') {
      if (typeof templateToCanvas !== 'function') { setStatus('Image export not yet available.', 'warning'); return; }
      const canvas = templateToCanvas(t);
      canvas.toBlob(function(blob) {
        downloadBlob(blob, safeName + '.png');
      }, 'image/png');
    }
    const modal = document.getElementById('exportModal');
    if (modal) modal.remove();
    setStatus('Exported: ' + t.name + ' (' + { em: 'EncounterManager', json: 'JSON', md: 'Markdown', image: 'Image' }[mode] + ')', 'success');
  } catch (e) {
    setStatus('Export failed: ' + e.message, 'error');
  }
}

function showImportMonsterDialog() {
  const bodyHtml =
    '<div class="modal-toggle-group">' +
    '<button id="importModeEM" class="active" onclick="switchImportMode(\'em\')">EncounterManager</button>' +
    '<button id="importMode5etools" onclick="switchImportMode(\'5etools\')">5etools</button>' +
    '</div>' +
    '<div id="importBody">' +
    '<p class="text-muted-sm" style="margin-bottom:0.75rem">Select one or more .squishtext or .json files containing monster templates.</p>' +
    '<input type="file" id="importFileInput" accept=".squishtext,.json" multiple style="margin-bottom:1rem;font-size:0.8rem;color:var(--text)">' +
    '<p style="font-size:0.7rem;color:var(--text-muted);margin-bottom:1rem">New monsters will be added. Existing monsters are kept (duplicates skipped by ID).</p>' +
    '</div>' +
    '<div class="flex-row-end">' +
    '<button class="btn-sm" onclick="document.getElementById(\'importModal\').remove()">Cancel</button>' +
    '<button class="btn-sm btn-action" onclick="doImportMonster()">Import</button>' +
    '</div>';
  createModal('importModal', 'Import Monsters', bodyHtml, { wide: true });
}

function switchImportMode(mode) {
  const activeId = mode === 'em' ? 'importModeEM' : 'importMode5etools';
  ['importModeEM', 'importMode5etools'].forEach(function(id) {
    const el = document.getElementById(id);
    if (el) el.className = id === activeId ? 'active' : '';
  });
  const body = document.getElementById('importBody');
  if (!body) return;
  const inputStyle = 'padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.85rem';
  if (mode === 'em') {
    body.innerHTML =
      '<p class="text-muted-sm" style="margin-bottom:0.75rem">Select one or more .squishtext or .json files containing monster templates.</p>' +
      '<input type="file" id="importFileInput" accept=".squishtext,.json" multiple style="margin-bottom:1rem;font-size:0.8rem;color:var(--text)">' +
      '<p style="font-size:0.7rem;color:var(--text-muted);margin-bottom:1rem">New monsters will be added. Existing monsters are kept (duplicates skipped by ID).</p>';
  } else if (mode === '5etools') {
    body.innerHTML =
      '<p class="text-muted-sm" style="margin-bottom:0.75rem">Paste 5etools creature JSON, or select .json files.</p>' +
      '<textarea id="importPasteInput" rows="6" placeholder="Paste 5etools JSON here..." style="width:100%;margin-bottom:0.75rem;font-family:var(--mono);' + inputStyle + '"></textarea>' +
      '<p class="text-muted-sm" style="margin-bottom:0.5rem">Or select .json files:</p>' +
      '<input type="file" id="importFileInput" accept=".json" multiple style="margin-bottom:1rem;font-size:0.8rem;color:var(--text)">' +
      '<p style="font-size:0.7rem;color:var(--text-muted);margin-bottom:0.75rem">Accepts single creatures or bestiary files with a "monster" array. Duplicates skipped by name.</p>' +
      '<p style="font-size:0.72rem;color:var(--danger);margin-bottom:0;padding:0.5rem 0.6rem;border:1px solid var(--danger);border-radius:var(--radius);background:rgba(255,80,80,0.08)">Warning: 5etools data varies widely in structure. Always review imported creatures and fix any issues - especially complex abilities like Mythic, Villain, or Epic Actions, which are best added as notes in the feature description.</p>';
  }
}

async function doImportMonster() {
  // Determine active mode
  const is5etools = document.getElementById('importMode5etools') &&
    document.getElementById('importMode5etools').className === 'active';

  const fileInput = document.getElementById('importFileInput');
  const pasteInput = document.getElementById('importPasteInput');
  const hasPaste = pasteInput && pasteInput.value.trim();
  const hasFiles = fileInput && fileInput.files && fileInput.files.length > 0;

  if (!hasPaste && !hasFiles) {
    setStatus(is5etools ? 'Paste JSON or select a file first.' : 'Select a file first.', 'warning');
    return;
  }

  try {
    const existingIds = new Set(state.templates.map(t => t.id));
    const existingNames = new Set(state.templates.map(t => t.name.toLowerCase()));
    let added = 0, dupes = 0, totalFound = 0;

    if (is5etools) {
      // Collect all JSON texts (paste + files)
      const jsonTexts = [];
      if (hasPaste) jsonTexts.push(pasteInput.value.trim());
      if (hasFiles) {
        for (const file of fileInput.files) {
          jsonTexts.push(await file.text());
        }
      }
      for (const text of jsonTexts) {
        const data = JSON.parse(text);
        const templates = import5etools(data);
        totalFound += templates.length;
        templates.forEach(function(t) {
          if (!existingNames.has(t.name.toLowerCase())) {
            state.templates.push(t);
            existingIds.add(t.id);
            existingNames.add(t.name.toLowerCase());
            added++;
          } else { dupes++; }
        });
      }
    } else {
      // EncounterManager mode (squishtext or json files)
      for (const file of fileInput.files) {
        const text = await file.text();
        let data;
        // Try SquishText first, fall back to raw JSON
        try {
          const decompressed = await decompress(text);
          data = JSON.parse(decompressed);
        } catch (e) {
          data = JSON.parse(text);
        }
        // Check if this is a 5etools format that was loaded as a file
        if (detect5eToolsFormat(data)) {
          const templates = import5etools(data);
          totalFound += templates.length;
          templates.forEach(function(t) {
            if (!existingNames.has(t.name.toLowerCase())) {
              state.templates.push(t);
              existingIds.add(t.id);
              existingNames.add(t.name.toLowerCase());
              added++;
            } else { dupes++; }
          });
        } else if (data.templates && data.templates.length) {
          totalFound += data.templates.length;
          data.templates.forEach(function(t) {
            if (!existingIds.has(t.id)) { state.templates.push(t); existingIds.add(t.id); added++; }
            else { dupes++; }
          });
        }
      }
    }
    if (totalFound === 0) throw new Error('No monster templates found');
    save('templates');
    const modal = document.getElementById('importModal');
    if (modal) modal.remove();
    setStatus('Imported ' + added + ' monster' + (added !== 1 ? 's' : '') + (dupes > 0 ? ' (' + dupes + ' duplicate' + (dupes !== 1 ? 's' : '') + ' skipped)' : '') + '.', 'success');
    render();
  } catch (e) {
    console.error('Monster import failed:', e);
    setStatus('Import failed: ' + e.message, 'error');
  }
}

// ═══════════════════════════════════════════════════════════════
// ── Dice Roller Modal ──
// ═══════════════════════════════════════════════════════════════

function showDiceRoller() {
  const bodyHtml =
    '<div class="text-dim-sm" style="margin-bottom:0.75rem;line-height:1.4">' +
    'Examples: <span style="font-family:var(--mono)">2d6+3</span> &middot; ' +
    '<span style="font-family:var(--mono)">1d20+5 adv</span> &middot; ' +
    '<span style="font-family:var(--mono)">4d6*10</span> &middot; ' +
    '<span style="font-family:var(--mono)">(2d8+4)*2</span><br>' +
    'Follows PEMDAS: * and / before + and -. Use parentheses to group: <span style="font-family:var(--mono)">(2d8+4)/2</span>' +
    '</div>' +
    '<div style="display:flex;gap:0.5rem;margin-bottom:0.75rem">' +
    '<input type="text" id="diceRollerInput" placeholder="2d6+3, 1d20+5 adv, (2d8+4)*2" ' +
    'style="flex:1;padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);' +
    'background:var(--bg);color:var(--text);font-size:0.85rem;font-family:var(--mono)" ' +
    'onkeydown="if(event.key===\'Enter\'){event.preventDefault();doDiceRoll()}">' +
    '<button class="btn-sm btn-action" onclick="doDiceRoll()">Roll</button>' +
    '</div>' +
    '<div id="diceRollerResults" style="max-height:300px;overflow-y:auto;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg)"></div>' +
    '<div class="flex-row-end" style="margin-top:0.75rem">' +
    '<button class="btn-sm" onclick="diceRollerHistory=[];renderDiceRollerResults()">Clear</button>' +
    '<button class="btn-sm" onclick="document.getElementById(\'diceRollerModal\').remove()">Close</button>' +
    '</div>';
  createModal('diceRollerModal', 'Dice Roller', bodyHtml, {
    clickOutsideClose: true, escapeClose: true, focusId: 'diceRollerInput', titleMargin: '0.25rem'
  });
  renderDiceRollerResults();
}

function doDiceRoll() {
  const input = document.getElementById('diceRollerInput');
  if (!input) return;
  const expr = input.value.trim();
  if (!expr) return;

  const result = rollDiceExpression(expr);

  if (result.error) {
    diceRollerHistory.unshift({ error: true, text: 'Invalid: ' + esc(expr) + ' -- ' + esc(result.error) });
  } else {
    diceRollerHistory.unshift({
      error: false,
      expression: result.input,
      mode: result.mode,
      breakdown: result.breakdown,
      total: result.total
    });
  }

  // Cap history at 50
  if (diceRollerHistory.length > 50) diceRollerHistory.length = 50;

  renderDiceRollerResults();
  input.select();
}

function renderDiceRollerResults() {
  const container = document.getElementById('diceRollerResults');
  if (!container) return;

  if (diceRollerHistory.length === 0) {
    container.innerHTML = '<div style="text-align:center;color:var(--text-dim);font-size:0.78rem;padding:1rem 0">No rolls yet</div>';
    return;
  }

  let html = '';
  for (let i = 0; i < diceRollerHistory.length; i++) {
    const entry = diceRollerHistory[i];
    if (entry.error) {
      html += '<div class="dice-roller-entry" style="color:var(--error)">' + entry.text + '</div>';
    } else {
      const showBreakdown = entry.breakdown !== String(entry.total);
      html += '<div class="dice-roller-entry">';
      html += '<span style="color:var(--text-muted);font-size:0.75rem">' + esc(entry.expression) + '</span>';
      if (showBreakdown) {
        html += '<span style="color:var(--text-dim);margin:0 0.25rem">&rarr;</span>';
        html += '<span style="font-family:var(--mono);font-size:0.8rem">' + esc(entry.breakdown) + '</span>';
      }
      html += '<span style="font-weight:700;color:var(--accent);font-size:0.9rem;margin-left:0.25rem">= ' + entry.total + '</span>';
      html += '</div>';
    }
  }
  container.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Storage Indicator ──
// ═══════════════════════════════════════════════════════════════

function updateStorageInfo() {
  const el = document.getElementById('storageInfo');
  if (!el) return;
  function fmt(b) {
    if (b < 1024) return b + ' B';
    if (b < 1024 * 1024) return (b / 1024).toFixed(1) + ' KB';
    if (b < 1024 * 1024 * 1024) return (b / (1024 * 1024)).toFixed(1) + ' MB';
    return (b / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
  }
  // Measure actual app data size (not origin-wide estimate which includes browser cache)
  var usage = 0;
  for (var k of Object.keys(STORAGE_KEYS)) {
    if (state[k] !== undefined) usage += new Blob([JSON.stringify(state[k])]).size;
  }
  if (navigator.storage && navigator.storage.estimate) {
    navigator.storage.estimate().then(function(est) {
      el.textContent = 'Storage: ' + fmt(usage) + ' / ' + fmt(est.quota || 0);
    }).catch(function() {
      el.textContent = 'Storage: ' + fmt(usage);
    });
  } else {
    el.textContent = 'Storage: ' + fmt(usage);
  }
}

// ═══════════════════════════════════════════════════════════════
// ── Init ──
// ═══════════════════════════════════════════════════════════════

load().then(() => {
  const savedView = state.preferences && state.preferences.view;
  const savedCombatId = state.preferences && state.preferences.activeCombatId;
  // Restore active combat ID before switchView (which would clear it)
  if (savedView === 'combat' && savedCombatId && state.combats.find(function(c) { return c.id === savedCombatId; })) {
    activeCombatId = savedCombatId;
    autoExpandedId = state.preferences.autoExpandedId || null;
  }
  if (savedView && ['templates', 'parties', 'encounters', 'combat'].includes(savedView)) {
    switchView(savedView);
  } else {
    render();
  }
  updateStorageInfo();
});
</script>

</body>
</html>
